{"meta":{"title":"技术小站","subtitle":null,"description":null,"author":"ZhangHutao","url":"https://hutaozhang.github.io","root":"/"},"pages":[{"title":"about","date":"2020-06-04T10:11:54.000Z","updated":"2021-01-27T12:10:16.857Z","comments":true,"path":"about/index.html","permalink":"https://hutaozhang.github.io/about/index.html","excerpt":"","text":""},{"title":"box","date":"2021-01-31T15:22:08.000Z","updated":"2021-01-31T15:22:08.515Z","comments":true,"path":"box/index.html","permalink":"https://hutaozhang.github.io/box/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-20T18:55:13.533Z","updated":"2021-01-20T18:55:13.533Z","comments":true,"path":"categories/index.html","permalink":"https://hutaozhang.github.io/categories/index.html","excerpt":"","text":""},{"title":"朋友","date":"2021-01-22T17:28:40.246Z","updated":"2021-01-22T17:28:40.246Z","comments":true,"path":"friends/index.html","permalink":"https://hutaozhang.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-01-21T17:28:39.374Z","updated":"2021-01-21T17:28:39.374Z","comments":true,"path":"tags/index.html","permalink":"https://hutaozhang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git常用命令","slug":"Git常见命令","date":"2021-02-03T01:27:43.759Z","updated":"2021-02-03T01:11:15.321Z","comments":true,"path":"2021/02/03/Git常见命令/","link":"","permalink":"https://hutaozhang.github.io/2021/02/03/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git常用命令一、本地操作：其它 git init：初始化本地库 git status：查看工作区、暂存区的状态 git add &lt;file name&gt;：将工作区的“新建/修改”添加到暂存区 git rm --cached &lt;file name&gt;：移除暂存区的修改 git commit &lt;file name&gt;：将暂存区的内容提交到本地库 tip：需要再编辑提交日志，比较麻烦，建议用下面带参数的提交方法 git commit -m &quot;提交日志&quot; &lt;file name&gt;：文件从暂存区到本地库 日志 git log：查看历史提交 tip：空格向下翻页，b向上翻页，q退出 git log --pretty=oneline：以漂亮的一行显示，包含全部哈希索引值 git log --oneline：以简洁的一行显示，包含简洁哈希索引值 git reflog：以简洁的一行显示，包含简洁哈希索引值，同时显示移动到某个历史版本所需的步数 版本控制 git reset --hard 简洁/完整哈希索引值：回到指定哈希值所对应的版本 git reset --hard HEAD：强制工作区、暂存区、本地库为当前HEAD指针所在的版本 git reset --hard HEAD^：后退一个版本 tip：一个^表示回退一个版本 git reset --hard HEAD~1：后退一个版本 tip：波浪线~后面的数字表示后退几个版本 比较差异 git diff：比较工作区和暂存区的所有文件差异 git diff &lt;file name&gt;：比较工作区和暂存区的指定文件的差异 git diff HEAD|HEAD^|HEAD~|哈希索引值 &lt;file name&gt;：比较工作区跟本地库的某个版本的指定文件的差异 分支操作 git branch -v：查看所有分支 git branch -d &lt;分支名&gt;：删除本地分支 git branch &lt;分支名&gt;：新建分支 git checkout &lt;分支名&gt;：切换分支 git merge &lt;被合并分支名&gt;：合并分支 tip：如master分支合并 hot_fix分支，那么当前必须处于master分支上，然后执行 git merge hot_fix 命令 tip2：合并出现冲突 ①删除git自动标记符号，如&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD、&gt;&gt;&gt;&gt;&gt;&gt;&gt;等 ②修改到满意后，保存退出 ③git add &lt;file name&gt; ④git commit -m &quot;日志信息&quot;，此时后面不要带文件名 二、本地库跟远程库交互：git clone &lt;远程库地址&gt;：克隆远程库 功能：①完整的克隆远程库为本地库，②为本地库新建origin别名，③初始化本地库 git remote -v：查看远程库地址别名 git remote add &lt;别名&gt; &lt;远程库地址&gt;：新建远程库地址别名 git remote rm &lt;别名&gt;：删除本地中远程库别名 git push &lt;别名&gt; &lt;分支名&gt;：本地库某个分支推送到远程库，分支必须指定 git pull &lt;别名&gt; &lt;分支名&gt;：把远程库的修改拉取到本地 tip：该命令包括git fetch，git merge git fetch &lt;远程库别名&gt; &lt;远程库分支名&gt;：抓取远程库的指定分支到本地，但没有合并 git merge &lt;远程库别名/远程库分支名&gt;：将抓取下来的远程的分支，跟当前所在分支进行合并 git fork：复制远程库 tip：一般是外面团队的开发人员fork本团队项目，然后进行开发，之后外面团队发起pull request，然后本团队进行审核，如无问题本团队进行merge（合并）到团队自己的远程库，整个流程就是本团队跟外面团队的协同开发流程，Linux的团队开发成员即为这种工作方式。 借用网上的图","categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"教程/Git","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hutaozhang.github.io/tags/Git/"},{"name":"命令","slug":"命令","permalink":"https://hutaozhang.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"Git碰到的坑","slug":"Git碰到的坑","date":"2021-02-03T01:27:43.759Z","updated":"2021-02-03T01:15:03.960Z","comments":true,"path":"2021/02/03/Git碰到的坑/","link":"","permalink":"https://hutaozhang.github.io/2021/02/03/Git%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"凡走过，必留下痕迹。才过的坑，印记更深！！！ Git 问题 问题：用户名密码正确，但是报错用户名密码错误 remote: Invalid username or password 方案: https://www.freesion.com/article/8250330335/ https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token error: RPC failed; curl 18 transfer closed with outstanding read data remaining fatal: The remote end hung up unexpectedly 方案： https://www.cnblogs.com/niudaben/p/12503650.html 这里http.postBuffer 5242880000 error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 方案： https://blog.csdn.net/lw545034502/article/details/90289437 问题：相同分支本地文件与GitHub不一致修改文件名大小写后重新提交代码，结果发现git status中并未找到该变化，究其原因是默认git配置了忽略大小写敏感 1234$ git status$ git config core.ignorecase true$ git config core.ignorecase false","categories":[{"name":"问题","slug":"问题","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"问题/Git","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hutaozhang.github.io/tags/Git/"},{"name":"问题","slug":"问题","permalink":"https://hutaozhang.github.io/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"Hexo 碰到的坑","slug":"Hexo碰到的坑","date":"2021-02-03T01:27:43.759Z","updated":"2021-02-03T01:34:49.587Z","comments":true,"path":"2021/02/03/Hexo碰到的坑/","link":"","permalink":"https://hutaozhang.github.io/2021/02/03/Hexo%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"凡走过，必留下痕迹。才过的坑，印记更深！！！ Hexo 碰到的坑 box 文件夹下index.html找不到 123456 hexo new page box 将box的page拷贝过来 hexo d &#96;&#96;&#96; 2. 文件名修改，hexo d 推不上过去 Hexo 路径下&#96;deploy_git.git\\config&#96; 修改为 &#96;ignorecase &#x3D; false&#96; 检查文件名大小写 git config core.ignorecase 设置忽略大小写 git config core.ignorecase false 1233. 本地测试与public不一致 &#96;hexo s&#96; 生成页面与 &#96;hexo g&#96; 生成页面不一致 hexo clean hexo server #浏览器打开index.html页面代码 hexo g #public下index.htm页面代码不一致 两个index.html不一致改变方法 解决办法：强行修改ejs文件。 部署是分支不正确 Hexo 的配置文件_config.yml，已修改branch，但是不起作用 解决办法：修改github默认分支","categories":[{"name":"问题","slug":"问题","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/"},{"name":"Hexo","slug":"问题/Hexo","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/Hexo/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://hutaozhang.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hutaozhang.github.io/tags/Hexo/"}]},{"title":"Nginx 安装","slug":"Nginx安装","date":"2021-02-03T01:27:43.759Z","updated":"2021-02-03T01:09:32.272Z","comments":true,"path":"2021/02/03/Nginx安装/","link":"","permalink":"https://hutaozhang.github.io/2021/02/03/Nginx%E5%AE%89%E8%A3%85/","excerpt":"","text":"Docker 安装 Nginx检查镜像docker search nginx root@JD:~# docker search nginx NAME DESCRIPTION STARS OFFICIAL AUTOMATED nginx Official build of Nginx. 14373 [OK] 拉取镜像docker pull nginx人懒，直接选官方的了。 查看镜像docker images nginx root@JD:~# docker images nginx REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest f6d0b4767a6c 3 weeks ago 133MB 启动一个简单 ngix 容器 启动docker run --name nginx-test -p 8081:80 -d nginx –name nginx容器名 -p 端口，容器端口80，映射到本机端口8081 -d 后台运行 检测容器是否运行docker ps root@JD:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4dbe23a3c86d nginx &quot;/docker-entrypoint.…&quot; About an hour ago Up About an hour 80/tcp, 0.0.0.0:8081-&gt;8081/tcp nginx-blog 查看运行效果命令行：curl 127.0.0.1:8081浏览器：localhost:8081 Nginx 高级配置挂载 创建挂载目录mkdir -p /root/nginx/&#123;conf,conf.d,logs,html&#125; /root/nginx/logs 目录将映射为 nginx 容器的日志目录 `/root/nginx/conf` 目录里的配置文件将映射为 nginx 容器的配置文件 `/root/nginx/conf.d`目录里的配置文件将映射为 nginx服务所需配置 `/root/nginx/html` 目录里的文件将映射为将要运行的项目 注意： 这里我搭配Git使用，详情参考： Git安装 配置文件聪明人（懒汉）：借用刚才启动简单实例的配置文件 cp /etc/nginx/nginx.conf /root/nginx/conf/ cp /etc/nginx/conf.d/default.conf /root/nginx/conf.d/default.conf 老实人： vim /root/nginx/conf/nginx.conf123456789101112131415161718192021222324252627user nginx;worker_processes 1;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;pid &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123;worker_connections 1024;&#125;http &#123;include &#x2F;etc&#x2F;nginx&#x2F;mime.types;default_type application&#x2F;octet-stream;log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;&#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main;sendfile on;#tcp_nopush on;keepalive_timeout 65;#gzip on;include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;&#125; vim /root/nginx/conf.d/default.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748server &#123;listen 8081;server_name localhost;#charset koi8-r;#access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;log&#x2F;host.access.log main;location &#x2F; &#123;root &#x2F;data&#x2F;nginx&#x2F;html;# root &#x2F;usr&#x2F;nginx&#x2F;html;index index.html index.htm;autoindex on;try_files $uri &#x2F;index&#x2F;index&#x2F;page.html;#try_files $uri &#x2F;index&#x2F;map&#x2F;page.html;&#125;#error_page 404 &#x2F;404.html;# redirect server error pages to the static page &#x2F;50x.html#error_page 500 502 503 504 &#x2F;50x.html;location &#x3D; &#x2F;50x.html &#123;root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;&#125;# proxy the PHP scripts to Apache listening on 127.0.0.1:80##location ~ \\.php$ &#123;# proxy_pass http:&#x2F;&#x2F;127.0.0.1;#&#125;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \\.php$ &#123;# root html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name;# include fastcgi_params;#&#125;# deny access to .htaccess files, if Apache&#39;s document root# concurs with nginx&#39;s one##location ~ &#x2F;\\.ht &#123;# deny all;#&#125;&#125; 部署命令 12345docker run -d -p 8081:8081 --name nginx-blog \\-v &#x2F;home&#x2F;git&#x2F;project&#x2F;blog:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \\-v &#x2F;root&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \\-v &#x2F;root&#x2F;nginx&#x2F;conf.d&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf \\-v &#x2F;root&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx nginx -v /home/git/project/blog:/usr/share/nginx/html blog文件用于存放项目文件-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf-v /root/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf-v /root/nginx/logs:/var/log/nginx 运行检查： curl localhost:8081 #localhost不行用127.0.0.1 服务器ip:8081","categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Ninx","slug":"教程/Ninx","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Ninx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://hutaozhang.github.io/tags/Nginx/"},{"name":"Docker","slug":"Docker","permalink":"https://hutaozhang.github.io/tags/Docker/"}]},{"title":"Git安装","slug":"Git安装","date":"2021-02-03T01:27:43.744Z","updated":"2021-02-03T01:10:28.226Z","comments":true,"path":"2021/02/03/Git安装/","link":"","permalink":"https://hutaozhang.github.io/2021/02/03/Git%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装 Git 安装 GitDebian或Ubuntu：apt-get install gitCentOS：yum install -y git安装完成，看版本：git --version Git 使用 添加用户信息useradd usernamepasswd password实例： 12345useradd git -m passwd gitsu gitcd &#x2F;home&#x2F;gitmkdir -p projec&#x2F;blog -m 会在home下创建一个对应文件夹 su git 安全考虑切换git用户创建文件 初始化仓库并设置hooks 1234567mkdir repository &amp;&amp; cd repositorygit init --bare blog.git &#x2F;&#x2F; 创建一个干净的仓库cd blog.git&#x2F;hooks 切换到当前目录下vi post-receive &#x2F;&#x2F; 创建 hook 钩子函数，输入了内容如下:#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;git&#x2F;project&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repository&#x2F;blog.git checkout -f 设置权限 123chmod +x post-receiveexit &#x2F;&#x2F; 退出到 root 登录 或者 su rootchown -R git:git &#x2F;home&#x2F;git&#x2F;repository&#x2F;blog.git &#x2F;&#x2F; 添加权限 出于安全考虑，禁用shell登录 12vi &#x2F;etc&#x2F;passwdgit:x:503:503::&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash 修改为：git:x:503:503::/home/git:/bin/git-shell或者git:x:1000:1000::/home/git: 本地测试Git Bash窗口下:默认：git clone git@192.168.1.11:/home/git/repository/blog.git修改了git默认端口：git clone git@192.168.1.11:6666/home/git/repository/blog.git git 替换成自己的用户名 @ 后面替换成自己的ip地址 ： 后面跟的是你的SSH端口号 端口号后面是你的目录 目录后面是你的.git文件 在blog目录下新建一个文件 test.txt 这是一个测试文件 123git add .git commit -m &quot;测试私人git仓库&quot;git push 服务器：hooks 会将文件存放到指定目录下 12cd &#x2F;home&#x2F;git&#x2F;project&#x2F;blog #切换到目标路径ls -l #这里应该能够看到test.txt文件","categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"教程/Git","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hutaozhang.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://hutaozhang.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Linux常用命令大全","slug":"Linux-命令","date":"2021-01-28T14:14:26.747Z","updated":"2021-01-28T14:32:11.188Z","comments":true,"path":"2021/01/28/Linux-命令/","link":"","permalink":"https://hutaozhang.github.io/2021/01/28/Linux-%E5%91%BD%E4%BB%A4/","excerpt":"","text":"系统信息arch 显示机器的处理器架构uname -m 显示机器的处理器架构uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统init 0 关闭系统telinit 0 关闭系统shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启reboot 重启logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构lstree 显示文件和目录由根目录开始的树形结构mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录 cp -r dir1 dir2 复制一个目录及子目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversaip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database JPS工具jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。 我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。 使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。 jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path. $&gt; jps23991 Jps23789 BossMain23651 Resin 比较常用的参数： -q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数$&gt; jps -q286802378923651 -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null $&gt; jps -m28715 Jps -m23789 BossMain23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名 $&gt; jps -l28729 sun.tools.jps.Jps23789 com.asiainfo.aimc.bossbi.BossMain23651 com.caucho.server.resin.Resin -v 输出传递给JVM的参数 $&gt; jps -v23789 BossMain28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl - Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl sudo jps看到的进程数量最全 jps 192.168.0.77 列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099 （前提是远程服务器提供jstatd服务） 注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。 转自：https://www.cnblogs.com/yjd_hycf_space/p/7730690.html 详细情况请参考sun官方文档。http://java.sun.com/j2se/1.7.0/docs/tooldocs/share/jps.html","categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Linux","slug":"教程/Linux","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://hutaozhang.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux","slug":"Linux","permalink":"https://hutaozhang.github.io/tags/Linux/"}]},{"title":"Jedis-Redis的Java的应用","slug":"Jedis-Redis与Java的应用","date":"2021-01-20T03:19:18.288Z","updated":"2021-01-28T14:31:41.813Z","comments":true,"path":"2021/01/20/Jedis-Redis与Java的应用/","link":"","permalink":"https://hutaozhang.github.io/2021/01/20/Jedis-Redis%E4%B8%8EJava%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"转载：Redis入门到精通-Redis与Java的应用 1. Jedis的使用Jedis就是redis支持java的第三方类库，我们可以使用Jedis类库操作redis数据库。 ​ 注意:Jedis2.7以上的版本才支持集群操作。 1.1 Maven依赖12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt;&lt;/dependency&gt; 1.2 连接redis服务12Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379); //默认端口6379 可以省略jedis.auth(&quot;redis&quot;); //无密码此步可省略 1.3 Redis Java String(字符串)12345Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379);jedis.auth(&quot;redis&quot;);​jedis.set(&quot;a&quot;, &quot;test1&quot;); // 存数据System.out.println(jedis.get(&quot;a&quot;)); // 取数据 1.4 Redis Java List(列表)123456789101112Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379);jedis.auth(&quot;redis&quot;);​//存储数据到列表中jedis.lpush(&quot;list1&quot;, &quot;Java&quot;);jedis.lpush(&quot;list1&quot;, &quot;Html5&quot;);jedis.lpush(&quot;list1&quot;, &quot;Python&quot;);// 获取存储的数据并输出List&lt;String&gt; list = jedis.lrange(&quot;list1&quot;, 0 ,-1);for(int i=0; i&lt;list.size(); i++) &#123; System.out.println(&quot;列表项为: &quot;+list.get(i));&#125; 1.5 Redis Java Keys12345678910Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379);jedis.auth(&quot;redis&quot;);​// 获取数据并输出Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);Iterator&lt;String&gt; it=keys.iterator() ;while(it.hasNext())&#123; String key = it.next(); System.out.println(key);&#125; 2. 将User表放入到 Redis缓存 ​ t_user表数据量很大，查询很频繁，鲜有更新操作，可以把t_user表放到redis缓存中，实现t_user表的快速查询。 ​ 测试过程中我们用到了object转jsonString 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 2.1 准备User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class User &#123; private String id; private String name; private int age; private String sex;​ public User() &#123; super(); &#125;​ public User(String id, String name, int age, String sex) &#123; super(); this.id = id; this.name = name; this.age = age; this.sex = sex; &#125;​ public String getId() &#123; return id; &#125;​ public void setId(String id) &#123; this.id = id; &#125;​ public String getName() &#123; return name; &#125;​ public void setName(String name) &#123; this.name = name; &#125;​ public int getAge() &#123; return age; &#125;​ public void setAge(int age) &#123; this.age = age; &#125;​ public String getSex() &#123; return sex; &#125;​ public void setSex(String sex) &#123; this.sex = sex; &#125;​ @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 2.2 将User的数据放入到Redis1234567891011121314151617Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379);jedis.auth(&quot;redis&quot;);​User u1 = new User(UUID.randomUUID().toString(),&quot;jack1&quot;,21,&quot;m&quot;);User u2 = new User(UUID.randomUUID().toString(),&quot;jack2&quot;,22,&quot;m&quot;);User u3 = new User(UUID.randomUUID().toString(),&quot;jack3&quot;,23,&quot;m&quot;);User u4 = new User(UUID.randomUUID().toString(),&quot;jack4&quot;,24,&quot;m&quot;);User u5 = new User(UUID.randomUUID().toString(),&quot;jack5&quot;,25,&quot;m&quot;);​Map&lt;String,String&gt; userMap = new HashMap&lt;String,String&gt;();userMap.put(&quot;u1&quot;,JSON.toJSONString(u1));userMap.put(&quot;u2&quot;,JSON.toJSONString(u2));userMap.put(&quot;u3&quot;,JSON.toJSONString(u3));userMap.put(&quot;u4&quot;,JSON.toJSONString(u4));userMap.put(&quot;u5&quot;,JSON.toJSONString(u5));​jedis.hmset(&quot;t_user&quot;,userMap); 到Redis数据库服务器上观察： 123456789101112131415127.0.0.1:6379&gt; keys *1) &quot;t_user&quot;127.0.0.1:6379&gt; hkeys t_user1) &quot;u1&quot;2) &quot;u3&quot;3) &quot;u4&quot;4) &quot;u5&quot;5) &quot;u2&quot;127.0.0.1:6379&gt; hvals t_user1) &quot;&#123;\\&quot;age\\&quot;:21,\\&quot;id\\&quot;:\\&quot;740a1778-de0e-4426-b231-1f97d290b13c\\&quot;,\\&quot;name\\&quot;:\\&quot;jack1\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;2) &quot;&#123;\\&quot;age\\&quot;:23,\\&quot;id\\&quot;:\\&quot;5133d99f-b8a0-4062-8624-89a5dc5c8e89\\&quot;,\\&quot;name\\&quot;:\\&quot;jack3\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;3) &quot;&#123;\\&quot;age\\&quot;:24,\\&quot;id\\&quot;:\\&quot;f6d1a709-5f2c-4564-bec6-b8f63eef6a86\\&quot;,\\&quot;name\\&quot;:\\&quot;jack4\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;4) &quot;&#123;\\&quot;age\\&quot;:25,\\&quot;id\\&quot;:\\&quot;4c8b4122-c9f9-41b2-ba29-c0de2a257370\\&quot;,\\&quot;name\\&quot;:\\&quot;jack5\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;5) &quot;&#123;\\&quot;age\\&quot;:22,\\&quot;id\\&quot;:\\&quot;e48c6616-75c2-4d04-9e90-31b69a4632a4\\&quot;,\\&quot;name\\&quot;:\\&quot;jack2\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;127.0.0.1:6379&gt; 2.3 使用Redis中的User缓存数据t_user表数据量大，查询缓慢，如何实现t_user表数据的快速查询； 123​select * from t_user where age =25;select * from t_user where sex = &#x27;m&#x27;；​select * from t_user where sex = &#x27;w&#x27;； ​ 我们可以使用redis中的set类型预先设定查询结果集。 1234567891011121314151617181920212223242526272829303132333435​Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379);jedis.auth(&quot;redis&quot;);​//假设现在有mybatis的三个查询操作//userMapper.getUserListByAge(25)//userMapper.getUserListBySex(&quot;m&quot;)//userMapper.getUserListBySex(&quot;f&quot;)​//预设查询结果集final String user_list_by_age_25 = &quot;user_list_by_age_25&quot;;final String user_list_by_sex_m = &quot;user_list_by_sex_m&quot;;final String user_list_by_sex_f = &quot;user_list_by_sex_f&quot;;​//在初始化redis缓存的时候,模拟预设查询结果集// (在真正的开发中,使用mybatis二级换从数据库查询后再缓存到redis)//定义userMap存放t_user表的所有数据Map&lt;String,String&gt; userMap = new HashMap&lt;String,String&gt;();​User u1 = new User(UUID.randomUUID().toString(),&quot;jack&quot;,21,&quot;m&quot;);userMap.put(&quot;u1&quot;,JSON.toJSONString(u1));//u1 满足性别为m的条件,即u1为userMapper.getUserListBySex(&quot;m&quot;)的查询结果集jedis.sadd(user_list_by_sex_m,&quot;u1&quot;);​User u2 = new User(UUID.randomUUID().toString(),&quot;rose&quot;,25,&quot;f&quot;);userMap.put(&quot;u2&quot;,JSON.toJSONString(u2));//u2 满足sex=&#x27;f&#x27; age=25jedis.sadd(user_list_by_sex_f,&quot;u2&quot;);jedis.sadd(user_list_by_age_25,&quot;u2&quot;);​User u3 = new User(UUID.randomUUID().toString(),&quot;jack3&quot;,23,&quot;m&quot;);userMap.put(&quot;u3&quot;,JSON.toJSONString(u3));//u3 满足sex=&#x27;m&#x27;jedis.sadd(user_list_by_sex_m,&quot;u3&quot;);​jedis.hmset(&quot;t_user&quot;,userMap); Redis服务器结果： 123456789101112131415161718192021127.0.0.1:6379&gt; keys *1) &quot;user_list_by_age_25&quot;2) &quot;user_list_by_sex_m&quot;3) &quot;t_user&quot;4) &quot;user_list_by_sex_f&quot;127.0.0.1:6379&gt; hkeys t_user1) &quot;u1&quot;2) &quot;u2&quot;3) &quot;u3&quot;127.0.0.1:6379&gt; hvals t_user1) &quot;&#123;\\&quot;age\\&quot;:21,\\&quot;id\\&quot;:\\&quot;65224362-26b7-4858-9dfd-6c8df8d0dcce\\&quot;,\\&quot;name\\&quot;:\\&quot;jack\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;2) &quot;&#123;\\&quot;age\\&quot;:25,\\&quot;id\\&quot;:\\&quot;cd23782e-90a5-4c80-8c31-d0c874e623f6\\&quot;,\\&quot;name\\&quot;:\\&quot;rose\\&quot;,\\&quot;sex\\&quot;:\\&quot;f\\&quot;&#125;&quot;3) &quot;&#123;\\&quot;age\\&quot;:23,\\&quot;id\\&quot;:\\&quot;e5bb2423-c821-4267-b77c-0abef4777113\\&quot;,\\&quot;name\\&quot;:\\&quot;jack3\\&quot;,\\&quot;sex\\&quot;:\\&quot;m\\&quot;&#125;&quot;127.0.0.1:6379&gt; smembers user_list_by_age_251) &quot;u2&quot;127.0.0.1:6379&gt; smembers user_list_by_sex_m1) &quot;u1&quot;2) &quot;u3&quot;127.0.0.1:6379&gt; smembers user_list_by_sex_f1) &quot;u2&quot;127.0.0.1:6379&gt; ​ 这样在程序中userMapper.getUserListByAge(25)就可以通过从redis服务器上获得user_list_by_age_25数据进行使用。 12345678Jedis jedis = new Jedis(&quot;10.0.31.144&quot;,6379);jedis.auth(&quot;redis&quot;);Set&lt;String&gt; userlist = jedis.smembers(&quot;user_list_by_sex_m&quot;);for(String u : userlist)&#123; //拿到对对应ser的json字符串 System.out.println(jedis.hget(&quot;t_user&quot;,u)); //...这里可以再使用json转object方法&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Jedis","slug":"教程/Jedis","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Jedis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://hutaozhang.github.io/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"https://hutaozhang.github.io/tags/Jedis/"},{"name":"Java","slug":"Java","permalink":"https://hutaozhang.github.io/tags/Java/"}]},{"title":"Redis搭建及使用","slug":"Redis-build","date":"2021-01-20T03:19:18.284Z","updated":"2021-01-28T14:27:00.481Z","comments":true,"path":"2021/01/20/Redis-build/","link":"","permalink":"https://hutaozhang.github.io/2021/01/20/Redis-build/","excerpt":"","text":"Docker 安装 Redis 系统环境：16.04.1-Ubuntu uname -a 获取 Redis 镜像 docker images #检查是否存在redis镜像 若已存在镜像 docker ps -a -q #查看镜像是否在运行 docker exec -it redis_test redis-server -v #redis_test 是运行redis名称 若不存在镜像 docker search redis #查看redis版本 docker pull redis:latest #获取最新redis版本 启动 Redis docker run -d -p 6379:6379 --name redis_test --restart=always redis #启动一个简单的redis服务 docker run -d -p 6379:6379 --name redis_test -v /usr/local/redis/redis.conf:/etc/redis/redis.conf --restart=always redis redis-server /etc/redis/redis.conf #配置文件见附件一 -d 后台运行 –restart=always #开机自启 -v #挂载路径：/usr/local/redis/redis.conf redis-server #以配置文件(/etc/redis/redis.conf)方式启动，配合-v使用;配置文件注意事项： bind 127.0.0.1 #注释掉这部分(同时protected-mode no)，这是限制redis只能本地访问 dir ./ #存放路径，（同时appendonly yes） #持久化搭配使用 protected-mode no #默认yes，开启保护模式，限制为本地访问 daemonize no#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程（可选），改为yes会使配置文件方式启动redis失败 测试docker exec -it redis_test redis-cliauth 123456 外部连接 软件：Another Redis Desktop Manager 下载：Gitee Github Redis Desktop Manager 免费版不支持SSH连接 Redis常用命令及Java使用 命令行 开启redis，进入命令行界面 设置缓存：set key value 获取缓存：get key 设置过期时间：setex key 失效时间(s) value 删除缓存：del key 工具使用 Redis Java 添加 pom.xml12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; application配置信息 123456789101112redis: database: 0 host: 127.0.0.1 port: 6379 password: # 如果未单独配置默认为空即可 timeout: 1000 jedis: pool: max-active: 8 max-wait: -1 max-idle: 8 min-idle: 0 jedis配置类Jedis - Redis与Java的应用整合springboot1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 @EnableCaching@Configurationpublic class RedisConfig &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.database&#125;&quot;) private Integer database; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private Integer port; @Value(&quot;$&#123;spring.redis.password&#125;&quot;) private String pwd; @Primary @Bean(name = &quot;jedisPoolConfig&quot;) @ConfigurationProperties(prefix = &quot;spring.redis.pool&quot;) public JedisPoolConfig jedisPoolConfig() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxWaitMillis(10000); return jedisPoolConfig; &#125; @Bean public RedisConnectionFactory redisConnectionFactory(JedisPoolConfig jedisPoolConfig) &#123; RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setDatabase(database); redisStandaloneConfiguration.setPassword(pwd); redisStandaloneConfiguration.setPort(port); JedisClientConfiguration.JedisPoolingClientConfigurationBuilder jpcb = (JedisClientConfiguration.JedisPoolingClientConfigurationBuilder) JedisClientConfiguration.builder(); jpcb.poolConfig(jedisPoolConfig); JedisClientConfiguration jedisClientConfiguration = jpcb.build(); return new JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration); &#125; /** * 配置redisTemplate针对不同key和value场景下不同序列化的方式 * * @param factory Redis连接工厂 * @return */ @Primary @Bean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(factory); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); template.setKeySerializer(stringRedisSerializer); template.setHashKeySerializer(stringRedisSerializer); Jackson2JsonRedisSerializer redisSerializer = new Jackson2JsonRedisSerializer(Object.class); template.setValueSerializer(redisSerializer); template.setHashValueSerializer(redisSerializer); template.afterPropertiesSet(); return template; &#125; @Bean IGlobalCache cache(RedisTemplate redisTemplate) &#123; return new AppRedisCacheManager(redisTemplate); &#125; &#125; redisTemplate封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376 /** * 系统全局Cache接口，具体缓存方式需要实现该接口 * * @author YuXD * @date 2021-01-05 10:38 * @since v1.0 */public interface IGlobalCache &#123; /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ boolean expire(String key, long time); /** * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ long getExpire(String key); /** * 判断key是否存在 * * @param key 键 * @return true 存在 false不存在 */ boolean hasKey(String key); /** * 删除缓存 * * @param key 可以传一个值 或多个 */ void del(String... key);// ============================String============================= /** * 普通缓存获取 * * @param key 键 * @return 值 */ Object get(String key); /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ boolean set(String key, Object value); /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ boolean set(String key, Object value, long time); /** * 递增 * * @param key 键 * @param delta 要增加几(大于0) * @return */ long incr(String key, long delta); /** * 递减 * * @param key 键 * @param delta 要减少几(小于0) * @return */ long decr(String key, long delta); /** * HashGet * * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ Object hget(String key, String item); /** * 获取hashKey对应的所有键值 * * @param key 键 * @return 对应的多个键值 */ Map&lt;Object, Object&gt; hmget(String key); /** * HashSet * * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ boolean hmset(String key, Map&lt;String, Object&gt; map); /** * HashSet 并设置时间 * * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ boolean hmset(String key, Map&lt;String, Object&gt; map, long time); /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ boolean hset(String key, String item, Object value); /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ boolean hset(String key, String item, Object value, long time); /** * 删除hash表中的值 * * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ void hdel(String key, Object... item); /** * 判断hash表中是否有该项的值 * * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ boolean hHasKey(String key, String item); /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ double hincr(String key, String item, double by); /** * hash递减 * * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ double hdecr(String key, String item, double by); /** * 根据key获取Set中的所有值 * * @param key 键 * @return */ Set&lt;Object&gt; sGet(String key); /** * 根据value从一个set中查询,是否存在 * * @param key 键 * @param value 值 * @return true 存在 false不存在 */ boolean sHasKey(String key, Object value); /** * 将数据放入set缓存 * * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ long sSet(String key, Object... values); /** * 将set数据放入缓存 * * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ long sSetAndTime(String key, long time, Object... values); /** * 获取set缓存的长度 * * @param key 键 * @return */ long sGetSetSize(String key); /** * 移除值为value的 * * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ long setRemove(String key, Object... values); /** * 获取list缓存的内容 * * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ List&lt;Object&gt; lGet(String key, long start, long end); /** * 获取list缓存的长度 * * @param key 键 * @return */ long lGetListSize(String key); /** * 通过索引 获取list中的值 * * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ Object lGetIndex(String key, long index); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ boolean lSet(String key, Object value); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ boolean lSet(String key, Object value, long time); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ boolean lSetAll(String key, List&lt;Object&gt; value); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ boolean lSetAll(String key, List&lt;Object&gt; value, long time); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ boolean rSet(String key, Object value); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ boolean rSet(String key, Object value, long time); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ boolean rSetAll(String key, List&lt;Object&gt; value); /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ boolean rSetAll(String key, List&lt;Object&gt; value, long time); /** * 根据索引修改list中的某条数据 * * @param key 键 * @param index 索引 * @param value 值 * @return */ boolean lUpdateIndex(String key, long index, Object value); /** * 移除N个值为value * * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ long lRemove(String key, long count, Object value); /** * 从redis集合中移除[start,end]之间的元素 * * @param key * @param stard * @param end * @return */ void rangeRemove(String key, Long stard, Long end); /** * 返回当前redisTemplate * * @return */ RedisTemplate getRedisTemplate();&#125; 附件一 配置文件 redis.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected-mode noport 6379tcp-backlog 511timeout 0tcp-keepalive 0loglevel noticelogfile &quot;&quot;databases 16save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir .&#x2F;slave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay noslave-priority 100appendonly noappendfilename &quot;appendonly.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes","categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Redis","slug":"教程/Redis","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://hutaozhang.github.io/tags/Redis/"},{"name":"Docker","slug":"Docker","permalink":"https://hutaozhang.github.io/tags/Docker/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-20T02:09:33.241Z","updated":"2021-01-20T02:09:33.241Z","comments":true,"path":"2021/01/20/hello-world/","link":"","permalink":"https://hutaozhang.github.io/2021/01/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"教程/Git","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Git/"},{"name":"问题","slug":"问题","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"问题/Git","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/Git/"},{"name":"Hexo","slug":"问题/Hexo","permalink":"https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/Hexo/"},{"name":"Ninx","slug":"教程/Ninx","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Ninx/"},{"name":"Linux","slug":"教程/Linux","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Linux/"},{"name":"Jedis","slug":"教程/Jedis","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Jedis/"},{"name":"Redis","slug":"教程/Redis","permalink":"https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Redis/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://hutaozhang.github.io/tags/Git/"},{"name":"命令","slug":"命令","permalink":"https://hutaozhang.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"问题","slug":"问题","permalink":"https://hutaozhang.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hutaozhang.github.io/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://hutaozhang.github.io/tags/Nginx/"},{"name":"Docker","slug":"Docker","permalink":"https://hutaozhang.github.io/tags/Docker/"},{"name":"服务器","slug":"服务器","permalink":"https://hutaozhang.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://hutaozhang.github.io/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"https://hutaozhang.github.io/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"https://hutaozhang.github.io/tags/Jedis/"},{"name":"Java","slug":"Java","permalink":"https://hutaozhang.github.io/tags/Java/"}]}