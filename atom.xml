<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术小站</title>
  
  
  <link href="https://hutaozhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://hutaozhang.github.io/"/>
  <updated>2021-03-09T13:39:51.693Z</updated>
  <id>https://hutaozhang.github.io/</id>
  
  <author>
    <name>ZhangHutao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor-03重要方法</title>
    <link href="https://hutaozhang.github.io/posts/12443.html"/>
    <id>https://hutaozhang.github.io/posts/12443.html</id>
    <published>2021-03-09T13:39:30.148Z</published>
    <updated>2021-03-09T13:39:51.693Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadPoolExecutor中重要方法"><a href="#ThreadPoolExecutor中重要方法" class="headerlink" title="ThreadPoolExecutor中重要方法"></a>ThreadPoolExecutor中重要方法</h4><h5 id="任务提交主逻辑：execute"><a href="#任务提交主逻辑：execute" class="headerlink" title="任务提交主逻辑：execute()"></a>任务提交主逻辑：execute()</h5><details style='background-color:#f9f2f4'>  <summary><font color='#c7254e' size='3px'>execute()源码</font></summary>  <pre>  public void execute(Runnable command) {      if (command == null)          throw new NullPointerException();      /*       * Proceed in 3 steps:       *       * 1. If fewer than corePoolSize threads are running, try to       * start a new thread with the given command as its first       * task.  The call to addWorker atomically checks runState and       * workerCount, and so prevents false alarms that would add       * threads when it shouldn't, by returning false.       *       * 2. If a task can be successfully queued, then we still need       * to double-check whether we should have added a thread       * (because existing ones died since last checking) or that       * the pool shut down since entry into this method. So we       * recheck state and if necessary roll back the enqueuing if       * stopped, or start a new thread if there are none.       *       * 3. If we cannot queue task, then we try to add a new       * thread.  If it fails, we know we are shut down or saturated       * and so reject the task.       */      int c = ctl.get();      if (workerCountOf(c) < corePoolSize) {          if (addWorker(command, true))              return;          c = ctl.get();      }      if (isRunning(c) && workQueue.offer(command)) {          int recheck = ctl.get();          if (! isRunning(recheck) && remove(command))              reject(command);          else if (workerCountOf(recheck) == 0)              addWorker(null, false);      }      else if (!addWorker(command, false))          reject(command);  }  </pre></details><p>以下对execute的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//获取线程池状态</span></span><br><span class="line">        <span class="comment">//第一次启动，默认值是 RUNNING（-536870912） 111 00000 00000000</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// workerCountOf(c) 线程池当前线程数</span></span><br><span class="line">        <span class="comment">// 如果线程池中工作线程数小于核心线程数，则新增一个worker，并结束逻辑执行</span></span><br><span class="line">        <span class="comment">// 如果新增worker失败，更新线程池状态</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING&lt; TERMINATED</span></span><br><span class="line">        <span class="comment">// private static boolean isRunning(int c) &#123;return c &lt; SHUTDOWN;&#125; runinng状态下为true</span></span><br><span class="line">        <span class="comment">// ArrayBlockingQueue.offer()</span></span><br><span class="line">        <span class="comment">// 如果线程池中工作线程数大于核心线程数，则将任务扔到阻塞队列 workQueue 中</span></span><br><span class="line">        <span class="comment">//如果线程池为running状态，并且可以将任务成功添加到workQueue，则创建一个新worker</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">// 如果线程池正在运行，并且成功将任务添加到 workQueue 中</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<span class="comment">// 如果线程池不运行，将任务从workQueue中移除，并执行拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">// 如果线程池运行，并且没有现成在工作，则创建一个新worker</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程池非running状态，或者 任务添加到 workQueue 中失败</span></span><br><span class="line">        <span class="comment">// 并且添加新worker失败，则执行拒绝策略</span></span><br><span class="line">        <span class="comment">// SHUTDOWN状态下，添加worker必然，因为SHUTDOWN不处理新的任务，所以会失败抛出异常</span></span><br><span class="line">        <span class="comment">// SHUTDOWN之上全部会添加失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="添加新线程：addWorker"><a href="#添加新线程：addWorker" class="headerlink" title="添加新线程：addWorker()"></a>添加新线程：addWorker()</h5><details style='background-color:#f9f2f4'>  <summary><font color='#c7254e' size='3px'>addWorker()源码</font></summary>  <pre>    <code>    /**       * Checks if a new worker can be added with respect to current       * pool state and the given bound (either core or maximum). If so,       * the worker count is adjusted accordingly, and, if possible, a       * new worker is created and started, running firstTask as its       * first task. This method returns false if the pool is stopped or       * eligible to shut down. It also returns false if the thread       * factory fails to create a thread when asked.  If the thread       * creation fails, either due to the thread factory returning       * null, or due to an exception (typically OutOfMemoryError in       * Thread.start()), we roll back cleanly.       *       * @param firstTask the task the new thread should run first (or       * null if none). Workers are created with an initial first task       * (in method execute()) to bypass queuing when there are fewer       * than corePoolSize threads (in which case we always start one),       * or when the queue is full (in which case we must bypass queue).       * Initially idle threads are usually created via       * prestartCoreThread or to replace other dying workers.       *       * @param core if true use corePoolSize as bound, else       * maximumPoolSize. (A boolean indicator is used here rather than a       * value to ensure reads of fresh values after checking other pool       * state).       * @return true if successful       */      private boolean addWorker(Runnable firstTask, boolean core) &#123;          retry:          for (;;) &#123;              int c = ctl.get();              int rs = runStateOf(c);<pre><code>          // Check if queue empty only if necessary.          if (rs &gt;= SHUTDOWN &amp;&amp;              ! (rs == SHUTDOWN &amp;&amp;                 firstTask == null &amp;&amp;                 ! workQueue.isEmpty()))              return false;          for (;;) &#123;              int wc = workerCountOf(c);              if (wc &gt;= CAPACITY ||                  wc &gt;= (core ? corePoolSize : maximumPoolSize))                  return false;              if (compareAndIncrementWorkerCount(c))                  break retry;              c = ctl.get();  // Re-read ctl              if (runStateOf(c) != rs)                  continue retry;              // else CAS failed due to workerCount change; retry inner loop          &#125;      &#125;      boolean workerStarted = false;      boolean workerAdded = false;      Worker w = null;      try &#123;          w = new Worker(firstTask);          final Thread t = w.thread;          if (t != null) &#123;              final ReentrantLock mainLock = this.mainLock;              mainLock.lock();              try &#123;                  // Recheck while holding lock.                  // Back out on ThreadFactory failure or if                  // shut down before lock acquired.                  int rs = runStateOf(ctl.get());                  if (rs &lt; SHUTDOWN ||                      (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;                      if (t.isAlive()) // precheck that t is startable                          throw new IllegalThreadStateException();                      workers.add(w);                      int s = workers.size();                      if (s &gt; largestPoolSize)                          largestPoolSize = s;                      workerAdded = true;                  &#125;              &#125; finally &#123;                  mainLock.unlock();              &#125;              if (workerAdded) &#123;                  t.start();                  workerStarted = true;              &#125;          &#125;      &#125; finally &#123;          if (! workerStarted)              addWorkerFailed(w);      &#125;      return workerStarted;  &#125;&lt;/code&gt;</code></pre><p>  </pre></p></details><p>以下是对addWorker的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ThreadPoolExecutor中重要方法&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor中重要方法&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor中重要方法&quot;&gt;&lt;/a&gt;ThreadPoolExecuto</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor-02构造函数</title>
    <link href="https://hutaozhang.github.io/posts/52671.html"/>
    <id>https://hutaozhang.github.io/posts/52671.html</id>
    <published>2021-03-09T13:39:30.145Z</published>
    <updated>2021-03-09T13:39:51.696Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadPoolExecutor中的构造函数"><a href="#ThreadPoolExecutor中的构造函数" class="headerlink" title="ThreadPoolExecutor中的构造函数"></a>ThreadPoolExecutor中的构造函数</h4><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>)</h5><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-RejectedExecutionHandler"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-RejectedExecutionHandler" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue, RejectedExecutionHandler)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>, RejectedExecutionHandler)</h5><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue, ThreadFactory)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>, ThreadFactory)</h5><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory-RejectedExecutionHandler"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory-RejectedExecutionHandler" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue, ThreadFactory, RejectedExecutionHandler)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>, ThreadFactory, RejectedExecutionHandler)</h5>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> :  AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize  线程池核心线程数量</li><li>maximumPoolSize 线程池最大数量</li><li>keepAliveTime  空闲线程存活时间</li><li>unit 时间单位</li><li>workQueue 线程池所使用的缓冲队列</li><li>threadFactory 线程池创建线程使用的工厂</li><li>handler  线程池对拒绝任务的处理策略</li></ul><p>  <strong>corePoolSize</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ThreadPoolExecutor中的构造函数&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor中的构造函数&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor中的构造函数&quot;&gt;&lt;/a&gt;ThreadPoolExec</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor-01成员变量</title>
    <link href="https://hutaozhang.github.io/posts/31498.html"/>
    <id>https://hutaozhang.github.io/posts/31498.html</id>
    <published>2021-03-09T13:39:30.142Z</published>
    <updated>2021-03-09T13:39:51.686Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadPoolExecutor中的重要成员变量"><a href="#ThreadPoolExecutor中的重要成员变量" class="headerlink" title="ThreadPoolExecutor中的重要成员变量"></a>ThreadPoolExecutor中的重要成员变量</h4><h5 id="AtomicInteger-ctl"><a href="#AtomicInteger-ctl" class="headerlink" title="AtomicInteger ctl"></a>AtomicInteger <code>ctl</code></h5>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>  AtomicInteger类型的ctl代表了ThreadPoolExecutor中的控制状态，它是一个复核类型的成员变量，是一个原子整数，借助高低位包装了两个概念：</p><p>  (1) <code>workerCount</code>：线程池中当前活动的线程数量，占据ctl的<font color=blue><strong><em>低29位</em></strong></font>；</p><p>  (2) <code>runState</code>：线程池运行状态，占据<code>ctl</code>的<font color=red><strong>高3位</strong></font>，有<code>RUNNING</code>、<code>SHUTDOWN</code>、<code>STOP</code>、<code>TIDYING</code>、<code>TERMINATED</code>五种状态。</p><blockquote><p>如下，红色为高3位，蓝色为低29位，共32位<br><font color=red>000</font> <font color=blue><strong><em>00000 00000000 00000000 00000000</em></strong></font></p></blockquote><p>  <strong>workerCount</strong><br>  workerCount 代表线程池中当前活动的线程数量，每当活跃线程数增加或减少时，<code>ctl</code>直接做相应数目的增减即可，十分方便。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>  <code>COUNT_BITS</code>: 代表了workerCount所占位数为29 （<code>Integer.SIZE</code>为32）<br>  <code>CAPACITY</code>: 代表workerCount最大值为536870911 (<code>(2^29)-1</code>)  </p><blockquote><p>位运算：1 &lt;&lt; COUNT_BITS<br>1 = 2^0 为  00000000 00000000 00000000 00000001<br>左移29位结果如下<br>00000000 00000000 00000000 00000001 –&gt; 001 0000 00000000 00000000 00000000</p></blockquote><p>  <strong>runState</strong><br>  runState 代表线程池运行状态：<code>RUNNING</code>(-536870912)、<code>SHUTDOWN</code>(0)、<code>STOP</code>(536870912)、<code>TIDYING</code>(1073741824)、<code>TERMINATED</code>(1610612736)<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// -1在Java底层是由32个1表示的，左移29为：111 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 0在Java底层是由32个0表示的，左移29为：000 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 1在Java底层是由前31个0加1个1表示的，左移29为：001 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 2在Java底层是由前30个0加1个10表示的，左移29为：010 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 3在Java底层是由前30个0加1个11表示的，左移29为：011 00000 00000000 00000000 00000000</span></span><br></pre></td></tr></table></figure></p><ul><li><code>RUNNING</code>(-536870912)：接受新任务，并处理队列任务</li><li><code>SHUTDOWN</code>(0)：不接受新任务，但会处理队列任务</li><li><code>STOP</code>(536870912)：不接受新任务，不会处理队列任务，而且会中断正在处理过程中的任务</li><li><code>TIDYING</code>(1073741824)：所有的任务已结束，workerCount为0，线程过渡到TIDYING状态，将会执行terminated()钩子方法</li><li><code>TERMINATED</code>(1610612736)：terminated()方法已经完成</li></ul><p>  <strong>NOTE：状态值大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING&lt; TERMINATED</strong></p><p>  <strong><em>状态转化：</em></strong></p><ol><li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法后，或者线程池实现了finalize方法，在里面调用了shutdown方法，即隐式调用；</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()方法后；</li><li>SHUTDOWN -&gt; TIDYING：线程池和队列均为空时；</li><li>STOP -&gt; TIDYING：线程池为空时；</li><li>TIDYING -&gt; TERMINATED：terminated()钩子方法完成时。</li></ol><p>  <strong>runStateOf()</strong><br>   <code>runStateOf(int c)</code>运行状态<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>~ 是按位取反的意思，CAPACITY表示的是高位的3个0，和低位的29个1，而~CAPACITY则表示高位的3个1，低位的29个0<br>~CAPACITY: 111 0000 00000000 00000000 00000000<br>&amp; 是与操作，入参c执行按位与操作，即高3位保持原样，低29位全部设置为0，也就获取了线程池的运行状态runState。</p></blockquote><p>  <strong>workerCountOf()</strong><br>  <code>workerCountOf(int c)</code>计算线程池当前线程数<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>~ 是按位取反的意思，CAPACITY表示的是高位的3个0，和低位的29个1，而~CAPACITY则表示高位的3个1，低位的29个0<br>~CAPACITY: 111 0000 00000000 00000000 00000000<br>&amp; 是与操作，入参c执行按位与操作，即高3位保持原样，低29位全部设置为0，也就获取了线程池的运行状态runState。</p></blockquote><p>  <strong>ctlOf()</strong><br>  <code>ctlOf(int rs, int wc)</code>初始化ctl<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>rs表示线程池运行状态runState，其是高3位有值，低29位全部为0的int<br>wc则代表线程池中有效线程的数量workerCount，其为高3位全部为0，而低29位有值得int<br>| 是 <strong>或</strong> 操作，，即用runState的高3位，workerCount的低29位填充的数字，而默认传入的runState、workerCount分别为RUNNING和0</p></blockquote><h5 id="BlockingQueue-lt-Runnable-gt-workQueue"><a href="#BlockingQueue-lt-Runnable-gt-workQueue" class="headerlink" title="BlockingQueue&lt;Runnable&gt; workQueue"></a><code>BlockingQueue&lt;Runnable&gt; workQueue</code></h5><p>   workQueue是用于持有任务并将其转换成工作线程worker的队列；</p><h5 id="HashSet-lt-Worker-gt-workers"><a href="#HashSet-lt-Worker-gt-workers" class="headerlink" title="HashSet&lt;Worker&gt; workers"></a><code>HashSet&lt;Worker&gt; workers</code></h5><p>   workers是包含线程池中所有工作线程worker的集合，仅仅当拥有mainLock锁时才能访问它；</p><h5 id="long-completedTaskCount"><a href="#long-completedTaskCount" class="headerlink" title="long completedTaskCount"></a><code>long completedTaskCount</code></h5><p>   completedTaskCount是已完成任务的计数器，只有在worker线程的终止，仅仅当拥有mainLock锁时才能访问它；</p><h5 id="volatile-ThreadFactory-threadFactory"><a href="#volatile-ThreadFactory-threadFactory" class="headerlink" title="volatile ThreadFactory threadFactory"></a><code>volatile ThreadFactory threadFactory</code></h5><p>   创建新线程的工厂类；</p><h5 id="volatile-RejectedExecutionHandler-handler"><a href="#volatile-RejectedExecutionHandler-handler" class="headerlink" title="volatile RejectedExecutionHandler handler"></a><code>volatile RejectedExecutionHandler handler</code></h5><p>   执行过程中shutdown时调用的handler；</p><h5 id="volatile-long-keepAliveTime"><a href="#volatile-long-keepAliveTime" class="headerlink" title="volatile long keepAliveTime"></a><code>volatile long keepAliveTime</code></h5><p>   空闲线程等待工作的超时时间（纳秒），即空闲线程存活时间；</p><h5 id="volatile-boolean-allowCoreThreadTimeOut"><a href="#volatile-boolean-allowCoreThreadTimeOut" class="headerlink" title="volatile boolean allowCoreThreadTimeOut"></a><code>volatile boolean allowCoreThreadTimeOut</code></h5><p>   默认值为false，如果为false，core线程在空闲时依然存活；如果为true，则core线程等待工作，直到时间超时至keepAliveTime；</p><h5 id="volatile-int-corePoolSize"><a href="#volatile-int-corePoolSize" class="headerlink" title="volatile int corePoolSize"></a><code>volatile int corePoolSize</code></h5><p>   核心线程池大小，保持存活的工作线程的最小数目，当小于corePoolSize时，会直接启动新的一个线程来处理任务，而不管线程池中是否有空闲线程；</p><h5 id="volatile-int-maximumPoolSize"><a href="#volatile-int-maximumPoolSize" class="headerlink" title="volatile int maximumPoolSize"></a><code>volatile int maximumPoolSize</code></h5><p>   线程池最大大小，也就是线程池中线程的最大数量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ThreadPoolExecutor中的重要成员变量&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor中的重要成员变量&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor中的重要成员变量&quot;&gt;&lt;/a&gt;ThreadPo</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecuto</title>
    <link href="https://hutaozhang.github.io/posts/36639.html"/>
    <id>https://hutaozhang.github.io/posts/36639.html</id>
    <published>2021-03-09T13:39:30.139Z</published>
    <updated>2021-03-09T13:39:51.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>别说话，开抄！！！<br>先赞后看，参考一下大神文章：<br><a href="https://blog.csdn.net/lipeng_bigdata/article/details/51232266" title="ThreadPoolExecutor源码分析（一）：重要成员变量">ThreadPoolExecutor源码分析（一）：重要成员变量</a><br><a href="http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" title="ThreadPoolExecutor源码分析（一）：重要成员变量">深入理解Java线程池：ThreadPoolExecutor</a></p></blockquote><h3 id="ThreadPoolExecutor-Demo"><a href="#ThreadPoolExecutor-Demo" class="headerlink" title="ThreadPoolExecutor Demo"></a>ThreadPoolExecutor Demo</h3><p>  没看过源码，写个Demo压压惊~<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"> <span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//自定义线程池</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>);</span><br><span class="line"> ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, queue);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line"> MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line"> pool.execute(myTask);</span><br><span class="line"> System.out.println(<span class="string">&quot;线程池中的线程数目：&quot;</span>+pool.getPoolSize()+<span class="string">&quot;,队列中等待执行的任务数量：&quot;</span>+pool.getQueue().size()+<span class="string">&quot;,已执行完的任务数目：&quot;</span>+pool.getCompletedTaskCount());</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> pool.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;正在执行task &quot;</span> + taskNum);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;task &quot;</span>+taskNum+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程图结构关系"><a href="#线程图结构关系" class="headerlink" title="线程图结构关系"></a>线程图结构关系</h3><ul><li><p><strong>线程池总图</strong><br><img src="java-resource-threadpool-all.png" class="lazyload" data-srcset="java-resource-threadpool-all.png" srcset="data:image/png;base64,666"></p></li><li><p><strong>ThreadPoolExecutor 继承关系</strong><br><img src="java-resource-threapoolexecutor.png" class="lazyload" data-srcset="java-resource-threapoolexecutor.png" srcset="data:image/png;base64,666"></p></li><li><p><strong>ThreadPoolExecutor 源码</strong>  </p><a href="/posts/31498.html" title="Java源码-ThreadPoolExecutor-01成员变量">Java源码-ThreadPoolExecutor-01成员变量</a> <a href="/posts/52671.html" title="Java源码-ThreadPoolExecutor-02构造函数">Java源码-ThreadPoolExecutor-02构造函数</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;别说话，开抄！！！&lt;br&gt;先赞后看，参考一下大神文章：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/lipeng_bigdata/article/details/51232266&quot; title=&quot;ThreadPoolExec</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>面试 Database 基础</title>
    <link href="https://hutaozhang.github.io/posts/25491.html"/>
    <id>https://hutaozhang.github.io/posts/25491.html</id>
    <published>2021-03-08T13:42:08.741Z</published>
    <updated>2021-03-08T13:47:45.838Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么使用数据库？"><a href="#为什么使用数据库？" class="headerlink" title="为什么使用数据库？"></a>为什么使用数据库？</h5><ul><li><p>数据保存在内存</p><p>优点： 存取速度快</p><p>缺点： 数据不能永久保存</p></li><li><p>数据保存在文件</p><p>优点： 数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p></li><li><p>数据保存在数据库</p><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p></li></ul><h5 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h5><p>  结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><p>  作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h5 id="什么是MYSQL"><a href="#什么是MYSQL" class="headerlink" title="什么是MYSQL?"></a>什么是MYSQL?</h5><p>  MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。<br>  MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h5 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h5><ul><li><p>第一范式：每个列都不可以再拆分。</p></li><li><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p></li><li><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p></li></ul><h5 id="MySQL有关权限的表都有哪几个？"><a href="#MySQL有关权限的表都有哪几个？" class="headerlink" title="MySQL有关权限的表都有哪几个？"></a>MySQL有关权限的表都有哪几个？</h5><p>  MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。<br>  这些权限表分别<code>user</code>，<code>db</code>，<code>table_priv</code>，<code>columns_priv和host</code>。下面分别介绍一下这些表的结构和内容：</p><ol><li><code>user</code>权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li><code>db</code>权限表：记录各个帐号在各个数据库上的操作权限。</li><li><code>table_priv</code>权限表：记录数据表级的操作权限。</li><li><code>columns_priv</code>权限表：记录数据列级的操作权限。</li><li><code>host</code>权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ol><h5 id="MySQL中binlog有几种录入模式？分别有什么区别？"><a href="#MySQL中binlog有几种录入模式？分别有什么区别？" class="headerlink" title="MySQL中binlog有几种录入模式？分别有什么区别？"></a>MySQL中binlog有几种录入模式？分别有什么区别？</h5><p>  有三种格式: <code>statement</code>, <code>row</code> 和 <code>mixed</code>。</p><ol><li><p><code>statement</code>模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</p></li><li><p><code>row</code>级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</p></li><li><p><code>mixed</code>，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</p><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p></li></ol><h5 id="MySQL支持哪些数据类型？"><a href="#MySQL支持哪些数据类型？" class="headerlink" title="MySQL支持哪些数据类型？"></a>MySQL支持哪些数据类型？</h5><p>  1、<strong>整数类型</strong>，包括<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p><p>  长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p><p>  例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p><p>  2、<strong>实数类型</strong><br>  <code>FLOAT</code>、<code>DOUBLE</code>、<code>DECIMAL</code></p><p>  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。</p><p>  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。</p><p>  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p><p>  3、<strong>字符串类型</strong><br>  <code>VARCHAR</code>、<code>CHAR</code>、<code>TEXT</code>、<code>BLOB</code></p><p>  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</p><p>  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</p><p>  VARCHAR存储的内容超出设置的长度时，内容会被截断。</p><p>  CHAR是定长的，根据定义的字符串长度分配足够的空间。</p><p>  CHAR会根据需要使用空格进行填充方便比较。</p><p>  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</p><p>  CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p>  <strong>使用策略：</strong><br>  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。  </p><p>  4、<strong>枚举类型</strong><br>  <code>ENUM</code>，把不重复的数据存储为一个预定义的集合。 </p><p>  有时可以使用ENUM代替常用的字符串类型。 </p><p>  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</p><p>  ENUM在内部存储时，其实存的是整数。</p><p>  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</p><p>  排序是按照内部存储的整数  </p><p>  5、<strong>日期和时间类型</strong><br>  <code>timestamp</code> <code>datetime</code><br>  尽量使用<code>timestamp</code>，空间效率高于<code>datetime</code></p><p>  用整数保存时间戳通常不方便处理。</p><p>  如果需要存储微妙，可以使用bigint存储。</p><p>  看到这里，这道真题是不是就比较容易回答了。 </p><h5 id="MySQL存储引擎有哪些？他们有什么区别？"><a href="#MySQL存储引擎有哪些？他们有什么区别？" class="headerlink" title="MySQL存储引擎有哪些？他们有什么区别？"></a>MySQL存储引擎有哪些？他们有什么区别？</h5><p>  存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>  常用的存储引擎有以下：</p><ul><li><p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p></li><li><p><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</p></li><li><p><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p><p>区别详情见： <a href="#form1">MyISAM与InnoDB区别</a></p></li></ul><h5 id="MySQL中MyISAM索引与InnoDB索引有什么区别？"><a href="#MySQL中MyISAM索引与InnoDB索引有什么区别？" class="headerlink" title="MySQL中MyISAM索引与InnoDB索引有什么区别？"></a>MySQL中MyISAM索引与InnoDB索引有什么区别？</h5><ul><li><p>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</p></li><li><p>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</p></li><li><p>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</p></li><li><p>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p></li></ul><h5 id="MySQL中InnoDB引擎的特性"><a href="#MySQL中InnoDB引擎的特性" class="headerlink" title="MySQL中InnoDB引擎的特性?"></a>MySQL中InnoDB引擎的特性?</h5><ul><li><p>插入缓冲（insert buffer)</p></li><li><p>二次写(double write)</p></li><li><p>自适应哈希索引(ahi)</p></li><li><p>预读(read ahead)</p></li></ul><h5 id="存储引擎的选择？"><a href="#存储引擎的选择？" class="headerlink" title="存储引擎的选择？"></a>存储引擎的选择？</h5><p>  如果没有特别的需求，使用默认的Innodb即可。</p><ul><li><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p></li><li><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p></li></ul><hr><h5 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h5><p><em>表单一： <a id="form1">MyISAM与InnoDB区别</a></em></p><table><thead><tr><th align="center"></th><th align="center">MyISAM</th><th align="center">Innodb</th></tr></thead><tbody><tr><td align="center">存储结构</td><td align="center">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td align="center">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td align="center">存储空间</td><td align="center">MyISAM可被压缩，存储空间较小</td><td align="center">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td align="center">可移植性、备份及恢复</td><td align="center">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td align="center">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td align="center">文件格式</td><td align="center">数据和索引是分别存储的，数据.MYD，索引.MYI</td><td align="center">数据和索引是集中存储的，.ibd</td></tr><tr><td align="center">记录存储顺序</td><td align="center">按记录插入顺序保存</td><td align="center">按主键大小有序插入</td></tr><tr><td align="center">外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">锁支持（锁是避免资源争用的一个机制，<br>MySQL锁对用户几乎是透明的）</td><td align="center">表级锁定</td><td align="center">行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td align="center">SELECT</td><td align="center">MyISAM更优</td><td align="center"></td></tr><tr><td align="center">NSERT、UPDATE、DELETE</td><td align="center"></td><td align="center">InnoDB更优</td></tr><tr><td align="center">select count(*)</td><td align="center">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td align="center"></td></tr><tr><td align="center">索引的实现方式</td><td align="center">B+树索引，myisam 是堆表</td><td align="center">B+树索引，Innodb 是索引组织表</td></tr><tr><td align="center">哈希索引</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;为什么使用数据库？&quot;&gt;&lt;a href=&quot;#为什么使用数据库？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用数据库？&quot;&gt;&lt;/a&gt;为什么使用数据库？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据保存在内存&lt;/p&gt;
&lt;p&gt;优点： 存取速度快&lt;/p&gt;
&lt;p&gt;缺</summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/"/>
    
    
    <category term="Database" scheme="https://hutaozhang.github.io/tags/Database/"/>
    
    <category term="基础" scheme="https://hutaozhang.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务</title>
    <link href="https://hutaozhang.github.io/posts/40486.html"/>
    <id>https://hutaozhang.github.io/posts/40486.html</id>
    <published>2021-03-08T11:05:45.244Z</published>
    <updated>2021-03-08T11:54:04.778Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h3><p>  Spring事务本质是对数据库事务的支持，如果数据库不支持事务（例如MySQL的MyISAM引擎不支持事务），则Spring事务也不会生效。</p><p>  Spring 既支持<font color=red>编程式事务管理</font>, 也支持<font color=red>声明式的事务管理</font>.</p><ul><li>编程式事务管理<br>将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码。</li></ul><ul><li>声明式的事务管理<br>它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。事务管理作为一种横切关注点, 可以通过 AOP 方法模块化。Spring 通过 Spring AOP 框架支持声明式事务管理。</li></ul><p>  <strong>Spring事务管理</strong><br>  Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。</p><p>  Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><p>  <em>SSM中，一般spring自己管理事务，属于声明式管理，如果让MyBatis来管理事务，会导致api形式的调用，也就是编程式事务。</em></p><p>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-structure.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-structure.png" srcset="data:image/png;base64,666" alt="Spring事务结构图"></p><p>  此接口的内容如下：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line"><span class="comment">// 由TransactionDefinition得到TransactionStatus对象</span></span><br><span class="line"> <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line"> <span class="comment">// 提交</span></span><br><span class="line"> <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line"> <span class="comment">// 回滚</span></span><br><span class="line"> <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><br>  从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。</p><p>  运行流程示例如下：<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-running.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-running.png" srcset="data:image/png;base64,666" alt="Spring事务运行流程图"></p><h4 id="事务管理器的不同实现"><a href="#事务管理器的不同实现" class="headerlink" title="事务管理器的不同实现"></a>事务管理器的不同实现</h4><p>  ① DataSourceTransactionManager<br>  在应用程序中只需要处理一个数据源，而且通过JDBC存取。<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>     </span></span><br><span class="line"><span class="tag">   <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p><p>  ② JtaTransactionManager<br>  在JAVAEE应用服务器上用JTA(Java Transaction API)进行事务管理。</p><p>  ③ HibernateTransactionManager<br>  如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。</p><p>  对于Hibernate3，需要在Spring上下文定义中添加如下的<code>&lt;bean&gt;</code>声明：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。</p><p>  当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p><h4 id="声明式的事务管理"><a href="#声明式的事务管理" class="headerlink" title="声明式的事务管理"></a>声明式的事务管理</h4><p>  事务管理是一种横切关注点</p><p>  ① <code>&lt;tx:advice&gt;</code> 元素定义<br>  为了在 Spring 2.x 中启用声明式事务管理, 可以通过 tx Schema 中定义的 <code>&lt;tx:advice&gt;</code> 元素声明事务通知, 为此必须事先将这个 Schema 定义添加到 <code>&lt;beans&gt;</code> 根元素中去。<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据方法名指定事务的属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;purchase&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  ② 声明了事务通知后, 就需要将它与切入点关联起来.<br>  由于事务通知是在 <a href="aop:config">aop:config</a> 元素外部声明的, 所以它无法直接与切入点产生关联. 所以必须在<a href="aop:config">aop:config</a> 元素中声明一个增强器通知与切入点关联起来.<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>  由于 Spring AOP 是基于代理的方法, 所以只能增强公共方法. 因此, 只有公有方法才能通过 Spring AOP 进行事务管理。</p><h3 id="Spring事务传播"><a href="#Spring事务传播" class="headerlink" title="Spring事务传播"></a>Spring事务传播</h3><p>  事务传播行为是指一个事务方法A被另一个事务方法B调用时，这个事务A应该如何处理。事务A应该在事务B中运行还是另起一个事务，这个有事务A的传播行为决定。</p><p>  事务传播属性定义<code>TransactionDefinition</code><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th align="left">常量名称</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">PROPAGATION_REQUIRED</td><td align="left">支持当前事务，如果当前没有事务，就新建一个事务。这是Spring 默认的事务的传播。</td></tr><tr><td align="left">PROPAGATION_SUPPORTS</td><td align="left">支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td align="left">PROPAGATION_MANDATORY</td><td align="left">支持当前事务，如果当前没有事务，就抛出异常。</td></tr><tr><td align="left">PROPAGATION_REQUIRES_NEW</td><td align="left">新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后， 不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获， 也可以不处理回滚操作。 使用JtaTransactionManager作为事务管理器</td></tr><tr><td align="left">PROPAGATION_NOT_SUPPORTED</td><td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。使用JtaTransactionManager作为事务管理器</td></tr><tr><td align="left">PROPAGATION_NEVER</td><td align="left">以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td align="left">PROPAGATION_NESTED</td><td align="left">如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</td></tr></tbody></table><ul><li><strong>PROPAGATION_REQUIRED</strong>  </li><li>PROPAGATION_SUPPORTS</li><li>PROPAGATION_MANDATORY</li><li>PROPAGATION_REQUIRES_NEW</li><li>PROPAGATION_NOT_SUPPORTED</li><li>PROPAGATION_NEVER</li><li>PROPAGATION_NESTED</li></ul><h3 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h3><p>  事务隔离级别定义<code>TransactionDefinition</code><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><br>|           隔离级别           |                                                         解释                                                          |<br>|:————————–:|:———————————————————————————————————————–:|<br>|     ISOLATION_DEFAULT      |  这是个 PlatfromTransactionManager 默认的隔离级别， 使用数据库默认的事务隔离级别。另外四个与 JDBC 的 隔离级别相对应。   |<br>| ISOLATION_READ_UNCOMMITTED | 这是事务最低的隔离级别，它允许另外一个事务可以看 到这个事务未提交的数据。这种隔离级别会产生脏读， 不可重复读和幻像读。  |<br>|  ISOLATION_READ_COMMITTED  | 保证一个事务修改的数据提交后才能被另外一个事务读 取。另外一个事务不能读取该事务未提交的数据。 ISOLATION_REPEATABLE_READ |<br>|   ISOLATION_SERIALIZABLE   | 这是花费最高代价但是最可靠的事务隔离级别。事务被 处理为顺序执行。                                                                                                                        |</p><h3 id="Spring事务基本配置样例"><a href="#Spring事务基本配置样例" class="headerlink" title="Spring事务基本配置样例"></a>Spring事务基本配置样例</h3>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;transactionAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception,RuntimeException,SQLException&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception,RuntimeException,SQLException&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;edit*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception,RuntimeException,SQLException&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;NOT_SUPPORTED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;transactionAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;transactionPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;transactionPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public * com.gupaoedu..*.service..*Service.*(..))&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;Spring的事务管理&quot;&gt;&lt;a href=&quot;#Spring的事务管理&quot; class=&quot;headerlink&quot; title=&quot;Spring的事务管理&quot;&gt;&lt;/a&gt;Spring的事务管理&lt;/h3&gt;&lt;p&gt;  Spring事务本质是对数据库事务的支</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Spring" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Spring/"/>
    
    
    <category term="事务" scheme="https://hutaozhang.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="Transaction" scheme="https://hutaozhang.github.io/tags/Transaction/"/>
    
    <category term="Spring" scheme="https://hutaozhang.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://hutaozhang.github.io/posts/63394.html"/>
    <id>https://hutaozhang.github.io/posts/63394.html</id>
    <published>2021-03-07T09:54:35.889Z</published>
    <updated>2021-03-08T11:05:13.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><a href="/posts/46219.html" title="Database 事务">Database 事务</a>  <a href="/posts/45033.html" title="Database 事务ACID特性">Database 事务ACID特性</a>  <a href="/posts/40486.html" title="Spring 事务">Spring 事务</a>  <a href="/posts/29528.html" title="面试 MySQL 事务">面试 MySQL 事务</a><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><a href="/posts/58986.html" title="MySQL 索引">MySQL 索引</a><a href="/posts/43567.html" title="面试 MySQL 索引">面试 MySQL 索引</a><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><a href="/posts/2460.html" title="面试 MySQL MVCC">面试 MySQL MVCC</a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h4&gt;&lt;a</summary>
      
    
    
    
    
    <category term="数据库" scheme="https://hutaozhang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引</title>
    <link href="https://hutaozhang.github.io/posts/58986.html"/>
    <id>https://hutaozhang.github.io/posts/58986.html</id>
    <published>2021-03-06T14:01:00.941Z</published>
    <updated>2021-03-08T10:02:48.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、索引概述"><a href="#一、索引概述" class="headerlink" title="一、索引概述"></a>一、索引概述</h3><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h5><h5 id="2-索引的原理"><a href="#2-索引的原理" class="headerlink" title="2. 索引的原理"></a>2. 索引的原理</h5><p>  MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>  只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>  FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建表的时候添加FULLTEXT索引</span><br><span class="line">CTREATE <span class="keyword">TABLE</span> my_table(</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    my_text TEXT,</span><br><span class="line">    FULLTEXT(my_text)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建表以后，在需要的时候添加FULLTEXT索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ADD</span> FULLTEXT INDEX ft_index(column_name);</span><br></pre></td></tr></table></figure><br>  全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">MATCH</span>(ft_index) AGAINST(<span class="string">&#x27;查询字符串&#x27;</span>);</span><br></pre></td></tr></table></figure></p><h5 id="BTree索引和B-Tree索引"><a href="#BTree索引和B-Tree索引" class="headerlink" title="BTree索引和B+Tree索引"></a>BTree索引和B+Tree索引</h5><ul><li><p>BTree索引</p><ul><li>BTree是平衡搜索多叉树，设树的度为2d（d&gt;1），高度为h，那么BTree要满足以一下条件：</li><li>每个叶子结点的高度一样，等于h；</li><li>每个非叶子结点由n-1个key和n个指针point组成，其中d&lt;=n&lt;=2d,key和point相互间隔，结点两端一定是key；</li><li>叶子结点指针都为null；</li><li>非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；</li></ul><p>BTree的结构如下：<br><img src="mysql-index-btree.png" class="lazyload" data-srcset="mysql-index-btree.png" srcset="data:image/png;base64,666" alt="BTree结构"><br>在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。</p></li><li><p>B+Tree索引<br>B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：</p><ul><li>B+Tree中的非叶子结点不存储数据，只存储键值；</li><li>B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；</li><li>B+Tree的每个非叶子节点由n个键值key和n个指针point组成；</li></ul><p>B+Tree的结构图如下：<br><img src="mysql-index-b+tree.png" class="lazyload" data-srcset="mysql-index-b+tree.png" srcset="data:image/png;base64,666" alt="B+Tree结构"></p></li></ul><p>  <strong>B+Tree对比BTree的优点：</strong><br>  1、磁盘读写代价更低<br>  一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p><p>  2、查询速度更稳定<br>  由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。</p><ul><li><p>带顺序索引的B+Tree<br>很多存储引擎在B+Tree的基础上进行了优化，添加了指向相邻叶节点的指针，形成了带有顺序访问指针的B+Tree，这样做是为了提高区间查找的效率，只要找到第一个值那么就可以顺序的查找后面的值。</p><p>B+Tree的结构图如下：<br><img src="mysql-index-b+tree2.png" class="lazyload" data-srcset="mysql-index-b+tree2.png" srcset="data:image/png;base64,666" alt="B+Tree结构"></p></li></ul><h5 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h5><p>  分析了MySQL的索引结构的实现原理，然后我们来看看具体的存储引擎怎么实现索引结构的，MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。</p><p>  聚簇索引的解释是:聚簇索引的顺序就是数据的物理存储顺序</p><p>  非聚簇索引的解释是:索引顺序与数据物理排列顺序无关</p><p>  （这样说起来并不好理解，让人摸不着头脑，清继续看下文，并在插图下方对上述两句话有解释）</p><p>  首先要介绍几个概念，在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。</p><h5 id="3-索引的优缺点"><a href="#3-索引的优缺点" class="headerlink" title="3. 索引的优缺点"></a>3. 索引的优缺点</h5><p>  优势：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；</p><p>  劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</p><h3 id="二、索引的使用场景"><a href="#二、索引的使用场景" class="headerlink" title="二、索引的使用场景"></a>二、索引的使用场景</h3><p>  数据库中表的数据量较大的情况下，对于查询响应时间不能满足业务需求，可以合理的使用索引提升查询效率。</p><h3 id="三、索引的分类和创建和修改删除等命令"><a href="#三、索引的分类和创建和修改删除等命令" class="headerlink" title="三、索引的分类和创建和修改删除等命令"></a>三、索引的分类和创建和修改删除等命令</h3><h5 id="1-基本索引类型"><a href="#1-基本索引类型" class="headerlink" title="1. 基本索引类型"></a>1. 基本索引类型</h5><p>  ① 普通索引（单列索引）</p><ul><li><p>创建普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建组合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(column1, column2, column3);</span><br></pre></td></tr></table></figure><p>② 唯一索引<br>用来建立索引的列的值必须是唯一的，允许空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name(<span class="string">&#x27;col&#x27;</span>)；</span><br></pre></td></tr></table></figure><p>④ 主键索引<br>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p>⑤ 全文索引<br>是目前搜索引擎使用的一种关键技术。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-创建的语句"><a href="#2-创建的语句" class="headerlink" title="2. 创建的语句"></a>2. 创建的语句</h5>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name[col_name data type]</span><br><span class="line">[<span class="keyword">unique</span><span class="operator">|</span>fulltext][index<span class="operator">|</span>key][index_name](col_name[length])[<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure><ul><li><p>unique|fulltext为可选参数，分别表示唯一索引、全文索引</p></li><li><p>index和key为同义词，两者作用相同，用来指定创建索引</p></li><li><p>col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</p></li><li><p>index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</p></li><li><p>length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</p></li><li><p>asc或desc指定升序或降序的索引值存储</p></li></ul><h5 id="3-索引的创建、查询和删除"><a href="#3-索引的创建、查询和删除" class="headerlink" title="3. 索引的创建、查询和删除"></a>3. 索引的创建、查询和删除</h5><ol><li><p>索引的创建  </p><ul><li>普通索引（单列索引）<br>单列索引是最基本的索引，它没有任何限制。</li></ul><ul><li>直接创建索引  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name);</span><br></pre></td></tr></table></figure></li><li>修改表结构的方式添加索引  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(col_name);</span><br></pre></td></tr></table></figure></li><li>创建表的时候同时创建索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `news` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT ,</span><br><span class="line">    `title` <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `content` <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">    `<span class="type">time</span>` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">    INDEX index_name (title(<span class="number">255</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>删除索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `表名` <span class="keyword">drop</span> index 索引名;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>复合索引（组合索引）</p></li><li><p>唯一索引</p></li><li><p>主键索引</p></li><li><p>全文索引</p></li></ol><h3 id="四、简单实例演示"><a href="#四、简单实例演示" class="headerlink" title="四、简单实例演示"></a>四、简单实例演示</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、索引概述&quot;&gt;&lt;a href=&quot;#一、索引概述&quot; class=&quot;headerlink&quot; title=&quot;一、索引概述&quot;&gt;&lt;/a&gt;一、索引概述&lt;/h3&gt;&lt;h5 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/MySQL/"/>
    
    
    <category term="索引" scheme="https://hutaozhang.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Index" scheme="https://hutaozhang.github.io/tags/Index/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Database 索引</title>
    <link href="https://hutaozhang.github.io/posts/28156.html"/>
    <id>https://hutaozhang.github.io/posts/28156.html</id>
    <published>2021-03-06T13:40:50.006Z</published>
    <updated>2021-03-07T10:07:56.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-数据库索引"><a href="#一、-数据库索引" class="headerlink" title="一、 数据库索引"></a>一、 数据库索引</h2><h4 id="数据库索引定义"><a href="#数据库索引定义" class="headerlink" title="数据库索引定义"></a>数据库索引定义</h4><p>  索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p><p>  <strong>简而言之：</strong> 索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p><h4 id="数据库索引类别"><a href="#数据库索引类别" class="headerlink" title="数据库索引类别"></a>数据库索引类别</h4><p>  数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为聚簇索引和非聚簇索引两种：<br>  <em>聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。</em></p><p>  根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。有关数据库所支持的索引功能的详细信息，请参见数据库文档。<br>  提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><p>  <strong>唯一索引</strong><br>  唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p><p>  <strong>主键索引</strong><br>  数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p><p>  *<strong>聚集索引</strong><br>  在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</p><p>  <strong>索引列</strong><br>  可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</p><p>  检查查询的WHERE和JOIN子句。在任一子句中包括的每一列都是索引可以选择的对象。对新索引进行试验以检查它对运行查询性能的影响。考虑已在表上创建的索引数量。最好避免在单个表上有很多索引。检查已在表上创建的索引的定义。最好避免包含共享列的重叠索引。</p><p>  检查某列中唯一数据值的数量，并将该数量与表中的行数进行比较。比较的结果就是该列的可选择性，这有助于确定该列是否适合建立索引，如果适合，确定索引的类型。</p><h4 id="数据库索引特性"><a href="#数据库索引特性" class="headerlink" title="数据库索引特性"></a>数据库索引特性</h4><p>  <strong>基本特点</strong><br>  建立索引的目的是加快对表中记录的查找或排序。为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。数据库索引就是为了提高表的搜索效率而对某些字段中的值建立的目录 。</p><p>  创建索引可以大大提高系统的性能。第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>  因为，增加索引也有许多不利的方面。第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>  <strong>优点</strong><br>  通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点 ：</p><ul><li>在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。</li><li>能提高数据的搜索及检索速度，符合数据库建立的初衷。</li><li>能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。</li><li>在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。</li><li>建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。</li></ul><p>  <strong>缺点</strong><br>  虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点：</p><ul><li>在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。</li><li>在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加</li><li>在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。</li></ul><p>  <strong>注意事项</strong><br>  索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：</p><ul><li><p>在经常需要搜索的列上，可以加快搜索的速度；</p></li><li><p>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p></li><li><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p></li><li><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p></li><li><p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点：</p></li><li><p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p></li><li><p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p></li><li><p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。</p></li><li><p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-数据库索引&quot;&gt;&lt;a href=&quot;#一、-数据库索引&quot; class=&quot;headerlink&quot; title=&quot;一、 数据库索引&quot;&gt;&lt;/a&gt;一、 数据库索引&lt;/h2&gt;&lt;h4 id=&quot;数据库索引定义&quot;&gt;&lt;a href=&quot;#数据库索引定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Database/"/>
    
    
    <category term="Database" scheme="https://hutaozhang.github.io/tags/Database/"/>
    
    <category term="索引" scheme="https://hutaozhang.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Index" scheme="https://hutaozhang.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>面试 MySQL MVCC</title>
    <link href="https://hutaozhang.github.io/posts/2460.html"/>
    <id>https://hutaozhang.github.io/posts/2460.html</id>
    <published>2021-03-06T13:40:23.288Z</published>
    <updated>2021-03-07T10:03:22.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前提概要"><a href="#一、前提概要" class="headerlink" title="一、前提概要"></a>一、前提概要</h4><blockquote><p>MVCC<br>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote><h5 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h5><p>  MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p><h5 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h5><p>  在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p><ul><li><p>当前读<br>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p></li><li><p>快照读<br>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p></li></ul><p>  <strong>当前读，快照读和MVCC的关系</strong></p><ul><li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li><li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li><li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</li></ul><h5 id="MVCC能解决什么问题，好处是？"><a href="#MVCC能解决什么问题，好处是？" class="headerlink" title="MVCC能解决什么问题，好处是？"></a>MVCC能解决什么问题，好处是？</h5><p>  <strong>数据库并发场景有三种，分别为：</strong></p><ul><li>读-读：不存在任何问题，也不需要并发控制</li><li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><p>  <strong>MVCC带来的好处是？</strong><br>  多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li><li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li></ul><p>  <strong>小结一下</strong><br>  总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p><ul><li>MVCC + 悲观锁<br>MVCC解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁<br>MVCC解决读写冲突，乐观锁解决写写冲突<br>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</li></ul><h4 id="二、MVCC的实现原理"><a href="#二、MVCC的实现原理" class="headerlink" title="二、MVCC的实现原理"></a>二、MVCC的实现原理</h4><p>  MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念</p><p>  <strong>隐式字段</strong><br>  每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><ul><li><p>DB_TRX_ID<br>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p></li><li><p>DB_ROLL_PTR<br>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p></li><li><p>DB_ROW_ID<br>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引<br>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-yincang.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-yincang.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></p><p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本</p></li></ul><p>  <strong>undo日志</strong></p><p>  undo log主要分为两种：</p><ul><li><p>insert undo log<br>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p></li><li><p>update undo log<br>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><blockquote><p>purge</p><ul><li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></blockquote><p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p><p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo1.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo1.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>二、 现在来了一个事务1对该记录的name做出了修改，改为Tom</p></li><li><p>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</p></li><li><p>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</p></li><li><p>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</p></li><li><p>事务提交后，释放锁<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo2.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo2.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>三、 又来了个事务2修改person表的同一个记录，将age修改为30岁</p></li><li><p>在事务2修改该行数据时，数据库也先为该行加锁</p></li><li><p>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</p></li><li><p>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</p></li><li><p>事务提交，释放锁<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo3.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo3.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p></li></ul><p>  <strong>Read View(读视图)</strong><br>  什么是Read View?<br>  什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>  所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>  Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p><p>  那么这个判断条件是什么呢？<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo4.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo4.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>  如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较</p><p>  在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p><blockquote><p>trx_list（名字我随便取的）<br>一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID<br>up_limit_id<br>记录trx_list列表中事务ID最小的ID<br>low_limit_id<br>ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p></blockquote><ul><li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li><li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li><li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li></ul><p>  <strong>整体流程</strong><br>  我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p><p>  整体的流程是怎么样的呢？我们可以模拟一下</p><ul><li>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo5.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo5.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo6.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo6.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo7.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo7.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo8.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo8.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li></ul><h3 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h3><h5 id="RR是如何在RC级的基础上解决不可重复读的？"><a href="#RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="RR是如何在RC级的基础上解决不可重复读的？"></a>RR是如何在RC级的基础上解决不可重复读的？</h5><p>  当前读和快照读在RR级别下的区别：<br>  表1:<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>  表2:<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc1.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc1.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>  而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p><ul><li><p>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。<br>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</p><p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p></li></ul><h5 id="RC-RR级别下的InnoDB快照读有什么不同？"><a href="#RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="RC,RR级别下的InnoDB快照读有什么不同？"></a>RC,RR级别下的InnoDB快照读有什么不同？</h5><p>  正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><ul><li><p>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p></li><li><p>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</p></li><li><p>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</p><p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前提概要&quot;&gt;&lt;a href=&quot;#一、前提概要&quot; class=&quot;headerlink&quot; title=&quot;一、前提概要&quot;&gt;&lt;/a&gt;一、前提概要&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;MVCC&lt;br&gt;MVCC，全称Multi-Version Concurrency </summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
    <category term="面试" scheme="https://hutaozhang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MVCC" scheme="https://hutaozhang.github.io/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>面试 MySQL 索引</title>
    <link href="https://hutaozhang.github.io/posts/43567.html"/>
    <id>https://hutaozhang.github.io/posts/43567.html</id>
    <published>2021-03-06T13:33:13.730Z</published>
    <updated>2021-03-08T15:10:00.920Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>  索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>  索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>  更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><h5 id="索引有哪些优点？"><a href="#索引有哪些优点？" class="headerlink" title="索引有哪些优点？"></a>索引有哪些优点？</h5><ul><li><p>索引的优点</p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul></li><li><p>索引的缺点</p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul></li></ul><h5 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h5><h5 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h5><ul><li><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p></li><li><p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</p></li><li><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</p></li></ul></li><li><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li><p>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</p></li><li><p>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</p></li></ul></li><li><p>全文索引： 是目前搜索引擎使用的一种关键技术。</p><ul><li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li></ul></li></ul><h5 id="索引的数据结构（BTree，B-Tree）"><a href="#索引的数据结构（BTree，B-Tree）" class="headerlink" title="索引的数据结构（BTree，B+Tree）"></a>索引的数据结构（BTree，B+Tree）</h5><p>  索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><ol><li><p>BTree<br>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p></li><li><p>B+Tree<br>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p></li><li><p>哈希索引<br>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p></li></ol><h5 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h5><p>  索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>  索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li><p>把创建了索引的列的内容进行排序</p></li><li><p>对排序结果生成倒排表</p></li><li><p>在倒排表内容上拼上数据地址链</p></li><li><p>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p></li></ol><h5 id="索引的算法有哪些？"><a href="#索引的算法有哪些？" class="headerlink" title="索引的算法有哪些？"></a>索引的算法有哪些？</h5><p>  索引算法有 BTree算法和Hash算法<br>  <strong>BTree算法</strong><br>  BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只要它的查询条件是一个不以通配符开头的常量</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;jack%&#x27;</span>; </span><br><span class="line"><span class="comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%jack&#x27;</span>; </span><br></pre></td></tr></table></figure></p><p>  <strong>Hash算法</strong><br>  Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><h5 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h5><ol><li><p>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</p></li><li><p>基数较小的类，索引效果较差，没有必要在此列建立索引</p></li><li><p>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p></li><li><p>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p></li></ol><h5 id="创建索引的原则？（重点）"><a href="#创建索引的原则？（重点）" class="headerlink" title="创建索引的原则？（重点）"></a>创建索引的原则？（重点）</h5><p>  索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>  1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>  2）较频繁作为查询条件的字段才去创建索引</p><p>  3）更新频繁字段不适合创建索引</p><p>  4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>  5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>  6）定义有外键的数据列一定要建立索引。</p><p>  7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>  8）对于定义为text、image和bit的数据类型的列不要建立索引。</p><h5 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a>创建索引的三种方式，删除索引</h5><p>  <strong>创建索引</strong><br>  第一种方式：在执行CREATE TABLE时创建索引<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">id <span class="type">INT</span> auto_increment <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">last_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">id_card <span class="type">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">information text,</span><br><span class="line">KEY name (first_name, last_name),</span><br><span class="line">FULLTEXT KEY (information),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>  第二种方式：使用ALTER TABLE命令去增加索引<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column_list);</span><br></pre></td></tr></table></figure><br>  ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。<br>  其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>  索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>  第三种方式：使用CREATE INDEX命令创建<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure><br>  CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p>  <strong>删除索引</strong><br>  根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code><br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY information;</span><br></pre></td></tr></table></figure></p><p>  删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> <span class="keyword">key</span>;</span><br><span class="line">[<span class="keyword">SQL</span>]<span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> <span class="keyword">KEY</span></span><br><span class="line">[Err]<span class="number">1075</span> <span class="operator">-</span> Incorrect <span class="keyword">table</span> definition, there can be <span class="keyword">only</span> <span class="keyword">one</span> auto <span class="keyword">column</span> <span class="keyword">and</span> it must be defined <span class="keyword">as</span> a key</span><br></pre></td></tr></table></figure><br>  需要取消自增长再行删除：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line">MODIFY id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure><br>  但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h5 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h5><ul><li><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p></li><li><p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p></li><li><p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p></li></ul><h5 id="使用索引时需要注意什么？"><a href="#使用索引时需要注意什么？" class="headerlink" title="使用索引时需要注意什么？"></a>使用索引时需要注意什么？</h5><p>  通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><ul><li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ul><h5 id="百万级别或以上的数据如何删除？"><a href="#百万级别或以上的数据如何删除？" class="headerlink" title="百万级别或以上的数据如何删除？"></a>百万级别或以上的数据如何删除？</h5><p>  关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><p>  语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>  前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>  实操的难度：在于前缀截取的长度。</p><p>  我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p><h5 id="什么是最左原则？什么是最左匹配原则？"><a href="#什么是最左原则？什么是最左匹配原则？" class="headerlink" title="什么是最左原则？什么是最左匹配原则？"></a>什么是最左原则？什么是最左匹配原则？</h5><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 </li><li></li><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li></li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h5 id="BTree和B-Tree的区别？"><a href="#BTree和B-Tree的区别？" class="headerlink" title="BTree和B+Tree的区别？"></a>BTree和B+Tree的区别？</h5><p>  在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p><p>  B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-btree-b+tree-diff.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-btree-b+tree-diff.png" srcset="data:image/png;base64,666" alt="B数和B+树的区别"></p><h5 id="使用BTree的好处？"><a href="#使用BTree的好处？" class="headerlink" title="使用BTree的好处？"></a>使用BTree的好处？</h5><p>  B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h5 id="使用B-Tree的好处？"><a href="#使用B-Tree的好处？" class="headerlink" title="使用B+Tree的好处？"></a>使用B+Tree的好处？</h5><p>  由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h5 id="Hash索引和B-Tree有什么区别或者说优劣？"><a href="#Hash索引和B-Tree有什么区别或者说优劣？" class="headerlink" title="Hash索引和B+Tree有什么区别或者说优劣？"></a>Hash索引和B+Tree有什么区别或者说优劣？</h5><p>  首先要知道Hash索引和B+树索引的底层实现原理：</p><p>  hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>  那么可以看出他们有以下的不同：</p><ul><li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p></li><li><p>hash索引不支持使用索引进行排序，原理同上。</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p></li><li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p></li><li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p></li></ul><h5 id="数据库为什么使用B-Tree而不是BTree？"><a href="#数据库为什么使用B-Tree而不是BTree？" class="headerlink" title="数据库为什么使用B+Tree而不是BTree？"></a>数据库为什么使用B+Tree而不是BTree？</h5><ul><li><p>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p></li><li><p>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</p></li><li><p>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</p></li><li><p>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</p></li><li><p>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p></li></ul><h5 id="B-Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据"><a href="#B-Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据" class="headerlink" title="B+Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据"></a>B+Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据</h5><p>  在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>  当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><h5 id="什么是聚簇索引？合适使用聚簇索引？"><a href="#什么是聚簇索引？合适使用聚簇索引？" class="headerlink" title="什么是聚簇索引？合适使用聚簇索引？"></a>什么是聚簇索引？合适使用聚簇索引？</h5><ul><li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p></li><li><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>何时使用聚簇索引与非聚簇索引<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-jucu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-jucu.png" srcset="data:image/png;base64,666" alt="何时使用聚簇索引与非聚簇索引"></p></li></ul><h5 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h5><p>  不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>  举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h5 id="联合索引时什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引时什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引时什么？为什么需要注意联合索引中的顺序？"></a>联合索引时什么？为什么需要注意联合索引中的顺序？</h5><p>  MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>  具体原因为:</p><p>  MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>  当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h5 id="索引是什么？有什么作用？"><a href="#索引是什么？有什么作用？" class="headerlink" title="索引是什么？有什么作用？"></a>索引是什么？有什么作用？</h5><p>  MySQL索引是什么？MySQL索引有什么作用？<br>  索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的IO成本。MySQL官方文档说500~800w条记录左右性能开始逐渐下降，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。</p><h5 id="导致SQL执行慢的原因"><a href="#导致SQL执行慢的原因" class="headerlink" title="导致SQL执行慢的原因"></a>导致SQL执行慢的原因</h5><ul><li>硬件问题。（如网速慢，内存不足，I / O 吞吐量小，磁盘空间满了等）</li><li>没有索引或索引失效。（一般在互联网公司，DBA会在半夜把表锁了，重新建立一遍索引，因为当你删除某个数据的时候，索引的树结构就不完整了。所以互联网公司的数据做的是假删除.一是为了做数据分析,二是为了不破坏索引）</li><li>数据过多。（官方文档说500W-800W条数据之后性能逐渐开始下降）</li><li>服务器调优及各个参数设置。（调整my.cnf）</li></ul><h5 id="如何解决这些问题呢？"><a href="#如何解决这些问题呢？" class="headerlink" title="如何解决这些问题呢？"></a>如何解决这些问题呢？</h5><ul><li>先观察，开启慢查询日志，设置相应的阈值（比如超过3秒就是慢SQL），在生产环境跑上个一天过后，看看哪些SQL比较慢。</li><li>Explain和慢SQL分析。比如SQL语句写的烂，索引没有或失效，关联查询太多（有时候是设计缺陷或者不得以的需求）等等。</li><li>Show Profile是比Explain更近一步的执行细节，可以查询到执行每一个SQL都干了什么事，这些事分别花了多少秒。</li><li>找DBA或者运维对MySQL进行服务器的参数调优。</li></ul><h5 id="什么是索引？-1"><a href="#什么是索引？-1" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。 Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引如图所示：<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-b+tree.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-b+tree.png" srcset="data:image/png;base64,666" alt="MySQL B+Tree"></p><p>最外层浅蓝色磁盘块1里有数据17、35（深蓝色）和指针P1、P2、P3（黄色）。P1指针表示小于17的磁盘块，P2是在17-35之间，P3指向大于35的磁盘块。真实数据存在于子叶节点也就是最底下的一层3、5、9、10、13…非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35。 查找过程：例如搜索28数据项，首先加载磁盘块1到内存中，发生一次I/O，用二分查找确定在P2指针。接着发现28在26和30之间，通过P2指针的地址加载磁盘块3到内存，发生第二次I/O。用同样的方式找到磁盘块8，发生第三次I/O。真实的情况是，上面3层的B+Tree可以表示上百万的数据，上百万的数据只发生了三次I/O而不是上百万次I/O，时间提升是巨大的。</p><p><strong>那我们在什么情况下该创建索引呢？</strong><br>索引虽然能非常高效的提高查询速度，同时却会降低更新表的速度。实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-create.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-create.png" srcset="data:image/png;base64,666" alt="MySQL B+Tree"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么是索引？&quot; class=&quot;headerlink&quot; title=&quot;什么是索引？&quot;&gt;&lt;/a&gt;什么是索引？&lt;/h5&gt;&lt;p&gt;  索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/MySQL/"/>
    
    
    <category term="索引" scheme="https://hutaozhang.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Index" scheme="https://hutaozhang.github.io/tags/Index/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
    <category term="面试" scheme="https://hutaozhang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试 MySQL 事务</title>
    <link href="https://hutaozhang.github.io/posts/29528.html"/>
    <id>https://hutaozhang.github.io/posts/29528.html</id>
    <published>2021-03-06T13:14:51.911Z</published>
    <updated>2021-03-08T15:23:43.504Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h5><p>  事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>  事务最经典也经常被拿出来说例子就是转账了。</p><p>  假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h5 id="事物的四大特性ACID介绍一下？"><a href="#事物的四大特性ACID介绍一下？" class="headerlink" title="事物的四大特性ACID介绍一下？"></a>事物的四大特性ACID介绍一下？</h5><ul><li><p>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p></li><li><p>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h5 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h5><ul><li><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p></li><li><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p></li><li><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p></li></ul><h5 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h5><p>  为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center"></td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center"></td><td align="center"></td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>  SQL 标准定义了四个隔离级别：</p><ul><li><p>READ-UNCOMMITTED(<strong>读取未提交</strong>)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p>READ-COMMITTED(<strong>读取已提交</strong>)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p>REPEATABLE-READ(<strong>可重复读</strong>)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p>SERIALIZABLE(<strong>可串行化</strong>)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h5&gt;&lt;p&gt;  事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状</summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
    <category term="面试" scheme="https://hutaozhang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Database 事务ACID特性</title>
    <link href="https://hutaozhang.github.io/posts/45033.html"/>
    <id>https://hutaozhang.github.io/posts/45033.html</id>
    <published>2021-03-06T09:52:38.367Z</published>
    <updated>2021-03-07T10:05:41.474Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-acidall.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-acidall.png" srcset="data:image/png;base64,666" alt="ACID作用"></p><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul><li><p><strong>原子性(Atomicity):</strong> 事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。</p></li><li><p><strong>一致性(Consistency):</strong> 事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。</p></li><li><p><strong>隔离性(Isolation):</strong> 并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。</p></li><li><p><strong>持久性(Durability):</strong> 事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p></li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面：</p><ol><li>事务的并发执行</li><li>事务故障或系统故障</li></ol><p>数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。<br>并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。<br>日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</p><p><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-acid.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-acid.png" srcset="data:image/png;base64,666" alt="ACID作用"></p><h3 id="事务特性–隔离性"><a href="#事务特性–隔离性" class="headerlink" title="事务特性–隔离性"></a>事务特性–隔离性</h3><h4 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h4><ol><li>脏读<br>脏读是指一个事务读取了另一个事务未提交的数据。<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-zangdu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-zangdu.png" srcset="data:image/png;base64,666" alt="脏读"><br>在事务1对A的处理过程中,事务2读取了A的值,但之后事务1回滚,导致事务2读取的A是未提交的脏数据。  </li></ol><p>  <strong>例子：</strong><br>  领导给张三发工资，10000元已打到张三账户，但该事务还未提交，正好这时候张三去查询工资，发现10000元已到账。这时领导发现张三工资算多了5000元，于是回滚了事务，修改了金额后将事务提交。最后张三实际到账的只有5000元。</p><ol start="2"><li>不可重复读<br>一次事务发生了两次读操作，两个读操作之间发生了另一个事务对数据修改操作，这时候第一次和第二次读到的数据不一致。  </li></ol><p>  <em>不可重复度关注点在数据更新和删除，通过行级锁可以实现可重复读的隔离级别。</em><br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-bukechongfudu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-bukechongfudu.png" srcset="data:image/png;base64,666" alt="不可重复读"><br>  由于事务2对A的已提交修改,事务1前后两次读取的结果不一致。<br>  <strong>例子：</strong><br>  张三需要转走1000元，系统读到卡余额有2000元，此时张三老婆正好需要转走2000元，并且在张三提交事务前把2000元转走了，当张三提交转账是系统提示余额不足。</p><ol start="3"><li>幻读<br>当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。  </li></ol><p>  <em>相对于不可重复读，幻读更关注其它事务的新增数据。通过行级锁可以避免不可重复读，但无法解决幻读的问题，想要解决幻读，只能通过Serializable隔离级别来实现。</em><br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-huandu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-huandu.png" srcset="data:image/png;base64,666" alt="不可重复读"><br>  事务1查询A&lt;5的数据,由于事务2插入了一条A=4的数据,导致事务1两次查询得到的结果不一样<br>  <strong>例子：</strong><br>  张三老婆准备打印张三这个月的信用卡消费记录，经查询发现消费了两次共1000元，而这时张三刚按摩完准备结账，消费了1000元，这时银行记录新增了一条1000元的消费记录。当张三老婆将消费记录打印出来时，发现总额变为了2000元，这让张三老婆很诧异。</p><ol start="4"><li><p>串行化读<br>Serializable是最高的隔离级别，性能很低，一般很少用。在这级别下，事务是串行顺序执行的，不仅避免了脏读、不可重复读，还避免了幻读。</p></li><li><p>丢失更新<br>丢失更新是指事务覆盖了其他事务对数据的已提交修改,导致这些修改好像丢失了一样。<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-diushigengxin.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-diushigengxin.png" srcset="data:image/png;base64,666" alt="丢失更新"></p></li><li><p>脏写<br>脏写是指事务回滚了其他事务对数据项的已提交修改。</p></li></ol><p>  <em>所有事务隔离级别都不允许出现脏写</em><br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-zangxie.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-zangxie.png" srcset="data:image/png;base64,666" alt="脏写"></p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table><thead><tr><th align="center">隔离级别</th><th align="center">隔离级别的值</th><th align="center">导致的问题</th></tr></thead><tbody><tr><td align="center">Read uncommitted(读未提交)</td><td align="center">0</td><td align="center">脏读，不可重复读，幻读</td></tr><tr><td align="center">Read committed(读已提交）</td><td align="center">1</td><td align="center">避免脏读，允许不可重复读和幻读</td></tr><tr><td align="center">Repeatable(可重复读)</td><td align="center">2</td><td align="center">MySQL默认的隔离级别。避免脏读，不可重复读，允许幻读</td></tr><tr><td align="center">Serializable(串行化)</td><td align="center">3</td><td align="center">串行化读，事务只能一个一个执行，避免了 脏读、不可重复读、幻读。执行效率慢，使用时慎重</td></tr></tbody></table><h5 id="事务隔离实现–并发控制"><a href="#事务隔离实现–并发控制" class="headerlink" title="事务隔离实现–并发控制"></a>事务隔离实现–并发控制</h5><p>  并发控制技术是实现事务隔离性以及不同隔离级别的关键,实现方式有很多,按照其对可能冲突的操作采取的不同策略可以分为乐观并发控制和悲观并发控制两大类。</p><ul><li><strong>乐观并发控制:</strong> 对于并发执行可能冲突的操作,假定其不会真的冲突,允许并发执行,直到真正发生冲突时才去解决冲突,比如让事务回滚。<ul><li>快照隔离</li><li>有效性检查</li></ul></li><li><strong>悲观并发控制:</strong> 对于并发执行可能冲突的操作,假定其必定发生冲突,通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。<ul><li>封锁</li><li>时间戳排序</li></ul></li></ul><h4 id="数据库故障与故障恢复"><a href="#数据库故障与故障恢复" class="headerlink" title="数据库故障与故障恢复"></a>数据库故障与故障恢复</h4><h5 id="故障种类"><a href="#故障种类" class="headerlink" title="故障种类"></a>故障种类</h5><p>  数据库运行过程中可能会出现故障,这些故障包括事务故障和系统故障两大类</p><ul><li><p>事务故障:比如非法输入,系统出现死锁,导致事务无法继续执行。</p></li><li><p>系统故障:比如由于软件漏洞或硬件错误导致系统崩溃或中止。</p><p>这些故障可能会对事务和数据库状态造成破坏,因而必须提供一种技术来对各种故障进行恢复,保证数据库一致性,事务的原子性以及持久性。数据库通常以日志的方式记录数据库的操作从而在故障时进行恢复,因而可以称之为日志恢复技术。</p></li></ul><h5 id="事务故障"><a href="#事务故障" class="headerlink" title="事务故障"></a>事务故障</h5><p>  事务的执行过程可以简化如下:</p><ol><li><p>系统会为每个事务开辟一个私有工作区</p></li><li><p>事务读操作将从磁盘中拷贝数据项到工作区中,在执行写操作前所有的更新都作用于工作区中的拷贝.</p></li><li><p>事务的写操作将把数据输出到内存的缓冲区中,等到合适的时间再由缓冲区管理器将数据写入到磁盘。</p><p>由于数据库存在立即修改和延迟修改,所以在事务执行过程中可能存在以下情况:</p></li><li><p>在事务提交前出现故障,但是事务对数据库的部分修改已经写入磁盘数据库中。这导致了事务的原子性被破坏。</p></li><li><p>在系统崩溃前事务已经提交,但数据还在内存缓冲区中,没有写入磁盘。系统恢复时将丢失此次已提交的修改。这是对事务持久性的破坏。</p></li></ol><h5 id="日志种类和格式"><a href="#日志种类和格式" class="headerlink" title="日志种类和格式"></a>日志种类和格式</h5><ul><li><p><code>&lt;T,X,V1,V2&gt;</code>:描述一次数据库写操作,T是执行写操作的事务的唯一标识,X是要写的数据项,V1是数据项的旧值,V2是数据项的新值。</p></li><li><p><code>&lt;T,X,V1&gt;</code>:对数据库写操作的撤销操作,将事务T的X数据项恢复为旧值V1。在事务恢复阶段插入。</p></li><li><p><code>&lt;T start&gt;</code>: 事务T开始</p></li><li><p><code>&lt;T commit&gt;</code>: 事务T提交</p></li><li><p><code>&lt;T abort&gt;</code>: 事务T中止</p><p>关于日志,有以下两条规则</p></li></ul><ol><li>系统在对数据库进行修改前会在日志文件末尾追加相应的日志记录。</li><li>当一个事务的commit日志记录写入到磁盘成功后,称这个事务已提交,但事务所做的修改可能并未写入磁盘</li></ol><h5 id="日志恢复的核心思想"><a href="#日志恢复的核心思想" class="headerlink" title="日志恢复的核心思想"></a>日志恢复的核心思想</h5><ul><li><p>撤销事务<code>undo</code>:将事务更新的所有数据项恢复为日志中的旧值,事务撤销完毕时将插入一条<code>&lt;T abort&gt;</code>记录。</p></li><li><p>重做事务<code>redo</code>:将事务更新的所有数据项恢复为日志中的新值。</p><p>事务正常回滚/因事务故障中止将进行<code>redo</code>。<br>系统从崩溃中恢复时将先进行redo再进行<code>undo</code>。</p><p>以下事务将进行undo:日志中只包括<code>&lt;T start&gt;</code>记录,但既不包括<code>&lt;T commit&gt;</code>记录也不包括<code>&lt;T abort&gt;</code>记录.<br>以下事务将进行redo:日志中包括<code>&lt;T start&gt;</code>记录,也包括<code>&lt;T commit&gt;</code>记录或<code>&lt;T abort&gt;</code>记录。</p><p>假设系统从崩溃中恢复时日志记录如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;T0 start&gt;</span><br><span class="line">&lt;T0,A,1000,950&gt;</span><br><span class="line">&lt;T0,B,2000,2050&gt;</span><br><span class="line">&lt;T0 commit&gt;</span><br><span class="line">&lt;T1 start&gt;</span><br><span class="line">&lt;T1,C,700,600&gt;</span><br></pre></td></tr></table></figure><p>由于T0既有start记录又有commit记录,将会对事务T0进行重做,执行相应的redo操作。<br>由于T1只有start记录,将会对T1进行撤销,执行相应的undo操作,撤销完毕将写入一条abort记录。</p></li></ul><h5 id="事务故障中止-正常回滚的恢复流程"><a href="#事务故障中止-正常回滚的恢复流程" class="headerlink" title="事务故障中止/正常回滚的恢复流程"></a>事务故障中止/正常回滚的恢复流程</h5><ol><li><p>从后往前扫描日志,对于事务T的每个形如<code>&lt;T,X,V1,V2&gt;</code>的记录,将旧值V1写入数据项X中。</p></li><li><p>往日志中写一个特殊的只读记录<code>&lt;T,X,V1&gt;</code>,表示将数据项恢复成旧值V1,这是一个只读的补偿记录,不需要根据它进行<code>undo</code>。</p></li><li><p>一旦发现了<code>&lt;T start&gt;</code>日志记录,就停止继续扫描,并往日志中写一个<code>&lt;T abort&gt;</code>日志记录。</p><p><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-guzhanghuifu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-guzhanghuifu.png" srcset="data:image/png;base64,666" alt="数据库故障恢复"></p></li></ol><h5 id="系统崩溃时的恢复过程-带检查点"><a href="#系统崩溃时的恢复过程-带检查点" class="headerlink" title="系统崩溃时的恢复过程(带检查点)"></a>系统崩溃时的恢复过程(带检查点)</h5><p>  检查点是形如<code>&lt;checkpoint L&gt;</code>的特殊的日志记录,L是写入检查点记录时还未提交的事务的集合,系统保证在检查点之前已经提交的事务对数据库的修改已经写入磁盘,不需要进行redo。检查点可以加快恢复的过程。</p><p>  系统奔溃时的恢复过程分为两个阶段:重做阶段和撤销阶段。</p><p>  重做阶段:</p><ol><li><p>系统从最后一个检查点开始正向的扫描日志,将要重做的事务的列表undo-list设置为检查点日志记录中的L列表。</p></li><li><p>发现<code>&lt;T,X,V1,V2&gt;</code>的更新记录或<code>&lt;T,X,V&gt;</code>的补偿撤销记录,就重做该操作。</p></li><li><p>发现<code>&lt;T start&gt;</code>记录,就把T加入到undo-list中。</p></li><li><p>发现<code>&lt;T abort&gt;</code>或<code>&lt;T commit&gt;</code>记录,就把T从undo-list中去除。</p><p>撤销阶段:</p></li><li><p>系统从尾部开始反向扫描日志</p></li><li><p>发现属于undo-list中的事务的日志记录,就执行undo操作</p></li><li><p>发现undo-list中事务的T的<code>&lt;T start&gt;</code>记录,就写入一条<code>&lt;T abort&gt;</code>记录,并把T从undo-list中去除。</p></li><li><p>undo-list为空,则撤销阶段结束</p><p>总结:先将日志记录中所有事务的更新按顺序重做一遍,在针对需要撤销的事务按相反的顺序执行其更新操作的撤销操作。</p><h5 id="一个系统崩溃恢复的例子"><a href="#一个系统崩溃恢复的例子" class="headerlink" title="一个系统崩溃恢复的例子"></a>一个系统崩溃恢复的例子</h5><p>恢复前的日志如下,写入最后一条日志记录后系统崩溃</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;T0 start&gt;</span><br><span class="line">&lt;T0,B,2000,2050&gt;</span><br><span class="line">&lt;T2 commit&gt;</span><br><span class="line">&lt;T1 start&gt;</span><br><span class="line">&lt;checkpoint &#123;T0,T1&#125;&gt;   &#x2F;&#x2F;之前T2已经commit,故不用重做</span><br><span class="line">&lt;T1,C,700,600&gt;</span><br><span class="line">&lt;T1 commit&gt;</span><br><span class="line">&lt;T2 start&gt;</span><br><span class="line">&lt;T2,A,500,400&gt;</span><br><span class="line">&lt;T0,B,2000&gt;</span><br><span class="line">&lt;T0 abort&gt;   &#x2F;&#x2F;T0回滚完成,插入该记录后系统崩溃</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-guzhanghuifu-sample.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-guzhanghuifu-sample.png" srcset="data:image/png;base64,666" alt="数据库故障恢复事例"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/database-acidall.png&quot; class=&quot;lazyload&quot; data-srcset=&quot;https://cdn.jsdelivr</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Database/"/>
    
    
    <category term="Database" scheme="https://hutaozhang.github.io/tags/Database/"/>
    
    <category term="事务" scheme="https://hutaozhang.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="Transaction" scheme="https://hutaozhang.github.io/tags/Transaction/"/>
    
    <category term="ACID" scheme="https://hutaozhang.github.io/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>Database 事务</title>
    <link href="https://hutaozhang.github.io/posts/46219.html"/>
    <id>https://hutaozhang.github.io/posts/46219.html</id>
    <published>2021-03-06T08:32:28.543Z</published>
    <updated>2021-03-07T10:07:20.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-数据库事务"><a href="#一、-数据库事务" class="headerlink" title="一、 数据库事务"></a>一、 数据库事务</h2><h4 id="数据库事务定义"><a href="#数据库事务定义" class="headerlink" title="数据库事务定义"></a>数据库事务定义</h4><p>数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><p>解析：</p><ul><li>Transaction</li><li>事务就是一段sql 语句的批处理，但是这个批处理是一个atom（原子），不可分割，要么都执行，要么回滚（rollback）都不执行。</li><li>一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成</li><li>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同</li></ul><h4 id="事务应用："><a href="#事务应用：" class="headerlink" title="事务应用："></a>事务应用：</h4><p>在数据库系统中，事务是工作的离散单位，它可以是修改一个用户的账户余额，可以是库存项的写操作，也可以是一个用户的删除。  </p><blockquote><ul><li>在单用户、单数据库环境下执行事务比较简单，但在分布式环境下，维护多个数据库的完整性就比较复杂。  </li><li>大多数联机事务处理系统是在大型计算机上实现的，这是由于它的操作复杂，需要快速的输入/输出和完善的管理。  </li><li>如果一个事务在多个场地进行修改，那就需要管理机制来防止数据重写并提供同步。  </li><li>另外还需要具有返回失效事务的能力，提供安全保障和提供数据恢复能力。 </li></ul></blockquote><p>数据库事务是一个逻辑上的划分，有的时候并不是很明显，它可以是一个操作步骤也可以是多个操作步骤。我们可以这样理解数据库事物:对数据库所做的一系列修改，在修改过程中，暂时不写入数据库，而是缓存起来，用户在自己的终端可以预览变化，直到全部修改完成，并经过检查确认无误后，一次性提交并写入数据库，在提交之前，必要的话所做的修改都可以取消。提交之后，就不能撤销，提交成功后其他用户才可以通过查询浏览数据的变化。</p><h4 id="事务优点"><a href="#事务优点" class="headerlink" title="事务优点"></a>事务优点</h4><p>以事务的方式对数据库进行访问，有如下的优点：<br>1、 把逻辑相关的操作分成了一个组；<br>2、 在数据永久改变前，可以预览数据变化；<br>3、 能够保证数据的读一致性</p><h4 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h4><p><em>事例1. 银行转账</em>  </p><ul><li><p>从第一个账户划出款项</p></li><li><p>将款项存入第二个账户</p><p>解析：在这个过程中，两个环节是关联的。第一个账户划出款项必须保证正确的存入第二个账户，如果第二个环节没有完成，整个的过程都应该取消，否则就会发生丢失款项的问题。整个交易过程，可以看作是一个事物，成功则全部成功，失败则需要全部撤消，这样可以避免当操作的中间环节出现问题时，产生数据不一致的问题。</p></li></ul><h2 id="二、-事务四大特性：ACID"><a href="#二、-事务四大特性：ACID" class="headerlink" title="二、 事务四大特性：ACID"></a>二、 事务四大特性：ACID</h2><p><strong>Atomicity（原子性）</strong><br>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p><strong>Consistency（一致性）</strong><br>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p><strong>Isolation（隔离性）</strong><br>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别:</p><ul><li>读未提交（Read uncommitted） 其它事务未提交就可以读</li><li>读提交（read committed） 其它事务只有提交了才能读</li><li>可重复读（repeatable read） 只管自己启动事务时候的状态,不受其它事务的影响(mysql默认)</li><li>串行化（Serializable） 按照顺序提交事务保证了数据的安全性,但无法实现并发</li></ul><p><em>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。</em></p><p><strong>Durability（持久性）</strong><br>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h2 id="三、-事务使用"><a href="#三、-事务使用" class="headerlink" title="三、 事务使用"></a>三、 事务使用</h2><h4 id="事务的术语"><a href="#事务的术语" class="headerlink" title="事务的术语"></a>事务的术语</h4><p>开启事务：Start Transaction<br>事务结束：End Transaction<br>提交事务：Commit Transaction<br>回滚事务：Rollback Transaction</p><h4 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h4><ul><li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li><li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li><li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li><li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>ROLLBACK TO identifier 把事务回滚到标记点；</li><li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li></ul><h4 id="事务开启和结束的标志"><a href="#事务开启和结束的标志" class="headerlink" title="事务开启和结束的标志"></a>事务开启和结束的标志</h4><p><strong>开启标志</strong></p><ul><li>任何一条DML语句(insert、update、delete)执行，标志事务的开启</li></ul><p><strong>结束标志</strong></p><ul><li>提交：成功的结束，将所有的DML语句操作历史记录和底层硬盘数据来一次同步</li><li>回滚：失败的结束，将所有的DML语句操作历史记录全部清空</li></ul><h4 id="事务与数据库底层数据"><a href="#事务与数据库底层数据" class="headerlink" title="事务与数据库底层数据"></a>事务与数据库底层数据</h4><p>在事物进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-数据库事务&quot;&gt;&lt;a href=&quot;#一、-数据库事务&quot; class=&quot;headerlink&quot; title=&quot;一、 数据库事务&quot;&gt;&lt;/a&gt;一、 数据库事务&lt;/h2&gt;&lt;h4 id=&quot;数据库事务定义&quot;&gt;&lt;a href=&quot;#数据库事务定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Database/"/>
    
    
    <category term="Database" scheme="https://hutaozhang.github.io/tags/Database/"/>
    
    <category term="事务" scheme="https://hutaozhang.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="Transaction" scheme="https://hutaozhang.github.io/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>GitHub</title>
    <link href="https://hutaozhang.github.io/posts/57711.html"/>
    <id>https://hutaozhang.github.io/posts/57711.html</id>
    <published>2021-02-24T17:51:10.885Z</published>
    <updated>2021-02-24T18:35:36.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注册-Github-账户"><a href="#注册-Github-账户" class="headerlink" title="注册 Github 账户"></a>注册 Github 账户</h3><ul><li>GitHub官网<a href="https://github.com/">点击此处</a> ，点击 Sign Up 注册账户<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github%E6%B3%A8%E5%86%8C.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github%E6%B3%A8%E5%86%8C.png" srcset="data:image/png;base64,666" alt="alt http://localhost:4000/" title="https://github.com/"></li></ul><h3 id="创建项目代码库"><a href="#创建项目代码库" class="headerlink" title="创建项目代码库"></a>创建项目代码库</h3><ul><li>页面左侧 Repository 点击按钮New步骤及注意事项见下图：<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" srcset="data:image/png;base64,666" alt="alt http://localhost:4000/" title="https://github.com/"></li></ul><h3 id="Git-免密登陆"><a href="#Git-免密登陆" class="headerlink" title="Git 免密登陆"></a>Git 免密登陆</h3><ul><li>右键，Git Bash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~&#x2F;.ssh</span><br></pre></td></tr></table></figure>如果没有，执行下一步。</li><li>新建 SSH Key<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your email@example.com&quot; </span><br></pre></td></tr></table></figure>接下来，一路enter到底。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key(&#x2F;c&#x2F;Users&#x2F;uestc&#x2F;.ssh&#x2F;id_rsa):</span><br><span class="line">Enter passphrase(empty for no passphrase)</span><br><span class="line">Your identification has been saved in &#x2F;c&#x2F;User&#x2F;uestc&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;uestc&#x2F;.ssh&#x2F;id_rsa.pub.</span><br></pre></td></tr></table></figure></li><li>将id_rsa.pub公钥中的内容添加到Git仓库设置中<ul><li>进入目录C:\Users\uestc.ssh，打开id_rsa.pub文件，并复制其中的所有内容<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-sshpub.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-sshpub.png" srcset="data:image/png;base64,666" alt="alt 本地公钥"></li><li>登录GitHub  <ul><li>点击右上角的头像 ，然后点击settings</li><li>选择SSH and GPG keys </li><li>New SSH key<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-sshkey.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-sshkey.png" srcset="data:image/png;base64,666" alt="alt 本地公钥"><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-ssh%E6%B7%BB%E5%8A%A0.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-ssh%E6%B7%BB%E5%8A%A0.png" srcset="data:image/png;base64,666" alt="alt 本地公钥"></li></ul></li></ul></li><li> 测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-ssh%E6%88%90%E5%8A%9F.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-ssh%E6%88%90%E5%8A%9F.png" srcset="data:image/png;base64,666" alt="alt 本地公钥"></li></ul><h3 id="配置本地个人信息"><a href="#配置本地个人信息" class="headerlink" title="配置本地个人信息"></a>配置本地个人信息</h3><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;此处填你的用户名&quot;  </span><br><span class="line">$ git config --global user.email  &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;注册-Github-账户&quot;&gt;&lt;a href=&quot;#注册-Github-账户&quot; class=&quot;headerlink&quot; title=&quot;注册 Github 账户&quot;&gt;&lt;/a&gt;注册 Github 账户&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;GitHub官网&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="GitHub" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/GitHub/"/>
    
    
    <category term="Git" scheme="https://hutaozhang.github.io/tags/Git/"/>
    
    <category term="GitHub" scheme="https://hutaozhang.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Blog搭建</title>
    <link href="https://hutaozhang.github.io/posts/2.html"/>
    <id>https://hutaozhang.github.io/posts/2.html</id>
    <published>2021-02-24T17:51:10.883Z</published>
    <updated>2021-02-24T18:33:19.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>Hexo<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></li><li><p>GitHub Pages<br>Github Pages允许用户的任何一个Repo的gh-pages分支上的代码可以经由HTTP访问到。类似提供了静态文件服务。</p></li><li><p>搭建私人Git仓库<br>Git是一个分布式版本控制软件，不仅能在服务器上实现版本控制，也能独立使用。虽然现在Github私有库全面开放，但是有些私密的小项目放在Github的服务器上总有些不安心。<br>这里我们使用私人仓库是因为github pages提供的静态文件服务带宽低，经常卡顿。</p></li></ul><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li><p>Git 安装<br>如果准备白嫖，只需安装本地Git即可。<br>安装方法： <a href="/posts/24585.html" title="Git安装">Git安装</a></p></li><li><p>Node 安装<br>安装地址：<a href="https://nodejs.org/en/download/">点击此处</a><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/node-download.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/node-download.png" srcset="data:image/png;base64,666" alt="alt Download | Node.js"></p></li><li><p>Hexo 安装</p></li></ol><ul><li>检查环境<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>注意：npm -v 不起作用，请先执行<code>npm install</code><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/blog%E7%8E%AF%E5%A2%83.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/blog%E7%8E%AF%E5%A2%83.png" srcset="data:image/png;base64,666" alt="alt 本地安装环境"></li><li>安装 Hexo<ul><li>创建本地Blog仓库：D:\workspace\Blog<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li><li>初始化Hexo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></li><li>测试Hexo服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>测试连接：<a href="http://localhost:4000/">http://localhost:4000/</a><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/hexo%E6%B5%8B%E8%AF%95.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/hexo%E6%B5%8B%E8%AF%95.png" srcset="data:image/png;base64,666" alt="alt http://localhost:4000/"></li></ul></li></ul><ol start="4"><li>GitHub Pages 部署博客</li></ol><ul><li>创建GitHub仓库：<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-blog.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-blog.png" srcset="data:image/png;base64,666" alt="alt http://localhost:4000/"><br>详情参考: <a href="/posts/57711.html" title="GitHub">GitHub</a><ul><li>登录 Github 打开自己的项目 your name.github.io</li><li>鼠标移到 Clone or download 按钮，选择 Use SSH</li><li>复制地址</li><li>打开_config.yml 文件（D:\workspace\Blog_config.yml）配置信息<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-blog%E4%BB%93%E5%BA%93.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-blog%E4%BB%93%E5%BA%93.png" srcset="data:image/png;base64,666" alt="alt http://localhost:4000/"><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-hexo%E9%85%8D%E7%BD%AE.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/github-hexo%E9%85%8D%E7%BD%AE.png" srcset="data:image/png;base64,666" alt="alt http://localhost:4000/"></li></ul></li><li>将本地仓库推送到远程仓库<br>Hexo安装git插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  </span><br></pre></td></tr></table></figure>编译部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>或者直接 hexo g d</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hexo&lt;br&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Blog" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Blog/"/>
    
    
    <category term="Hexo" scheme="https://hutaozhang.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo优化之永久链接</title>
    <link href="https://hutaozhang.github.io/posts/1.html"/>
    <id>https://hutaozhang.github.io/posts/1.html</id>
    <published>2021-02-24T17:51:10.881Z</published>
    <updated>2021-02-24T18:34:40.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Hexo默认的静态URL格式是 :year/:month/:day/:title，也就是按照年、月、日、标题来生成固定链接的。如<a href="http://xxx.yy.com/2020/07/06/hello-world">http://xxx.yy.com/2020/07/06/hello-world</a></p><p>这种默认配置的缺点就是一般文件名是中文，导致url链接里有中文出现，这会造成很多问题，也不利于seo，另外就是年月日都会有分隔符。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><blockquote><p>info,百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</p></blockquote><blockquote><p>success,搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。</p></blockquote><p>使用 hexo-abbrlink 插件可以完美解决，具体使用方法如下：</p><ul><li>安装npm包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li><li>修改_config.yml文件中的配置项（记得把原来的permalink:删除掉）:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts&#x2F;:abbrlink.html  # 此处可以自己设置，也可以直接使用 :&#x2F;abbrlink</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: dec     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure><h4 id="关于插件设置"><a href="#关于插件设置" class="headerlink" title="关于插件设置"></a>关于插件设置</h4>Abbrlink插件拥有两项设置选项:</li><li>alg: 算法(目前支持crc16和crc32算法，默认值是crc16)</li><li>rep: 形式(生成的链接可以是十六进制格式也可以是十进制格式，默认值是十进制格式)</li></ul><p>事例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;www.heson10.com&#x2F;posts&#x2F;55c6.html</span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;www.heson10.com&#x2F;posts&#x2F;43212.html</span><br><span class="line"> </span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;www.heson10.com&#x2F;posts&#x2F;6ec16a2c.html</span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;www.heson10.com&#x2F;posts&#x2F;1521457752.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Hexo默认的静态URL格式是 :year/:month/:day/:title，也就是按照年、月、日、标题来生成固定链接的。如&lt;a hre</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Blog" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Blog/"/>
    
    
    <category term="Hexo" scheme="https://hutaozhang.github.io/tags/Hexo/"/>
    
    <category term="优化" scheme="https://hutaozhang.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://hutaozhang.github.io/posts/7065.html"/>
    <id>https://hutaozhang.github.io/posts/7065.html</id>
    <published>2021-02-03T01:27:43.759Z</published>
    <updated>2021-02-24T17:25:44.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="一、本地操作："><a href="#一、本地操作：" class="headerlink" title="一、本地操作："></a>一、本地操作：</h2><p>其它</p><pre><code>git init：初始化本地库git status：查看工作区、暂存区的状态git add &lt;file name&gt;：将工作区的“新建/修改”添加到暂存区git rm --cached &lt;file name&gt;：移除暂存区的修改git commit &lt;file name&gt;：将暂存区的内容提交到本地库　　tip：需要再编辑提交日志，比较麻烦，建议用下面带参数的提交方法git commit -m &quot;提交日志&quot; &lt;file name&gt;：文件从暂存区到本地库</code></pre><p>日志</p><pre><code>git log：查看历史提交　　tip：空格向下翻页，b向上翻页，q退出git log --pretty=oneline：以漂亮的一行显示，包含全部哈希索引值git log --oneline：以简洁的一行显示，包含简洁哈希索引值git reflog：以简洁的一行显示，包含简洁哈希索引值，同时显示移动到某个历史版本所需的步数</code></pre><p>版本控制</p><pre><code>git reset --hard 简洁/完整哈希索引值：回到指定哈希值所对应的版本git reset --hard HEAD：强制工作区、暂存区、本地库为当前HEAD指针所在的版本git reset --hard HEAD^：后退一个版本　　　　tip：一个^表示回退一个版本git reset --hard HEAD~1：后退一个版本　　tip：波浪线~后面的数字表示后退几个版本</code></pre><p>比较差异</p><pre><code>git diff：比较工作区和暂存区的所有文件差异git diff &lt;file name&gt;：比较工作区和暂存区的指定文件的差异git diff HEAD|HEAD^|HEAD~|哈希索引值 &lt;file name&gt;：比较工作区跟本地库的某个版本的指定文件的差异</code></pre><p>分支操作</p><pre><code>git branch -v：查看所有分支git branch -d &lt;分支名&gt;：删除本地分支git branch &lt;分支名&gt;：新建分支git checkout &lt;分支名&gt;：切换分支git merge &lt;被合并分支名&gt;：合并分支　　tip：如master分支合并 hot_fix分支，那么当前必须处于master分支上，然后执行 git merge hot_fix 命令　　tip2：合并出现冲突　　　　①删除git自动标记符号，如&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD、&gt;&gt;&gt;&gt;&gt;&gt;&gt;等　　　　②修改到满意后，保存退出　　　　③git add &lt;file name&gt;　　　　④git commit -m &quot;日志信息&quot;，此时后面不要带文件名</code></pre><h2 id="二、本地库跟远程库交互："><a href="#二、本地库跟远程库交互：" class="headerlink" title="二、本地库跟远程库交互："></a>二、本地库跟远程库交互：</h2><pre><code>git clone &lt;远程库地址&gt;：克隆远程库　　功能：①完整的克隆远程库为本地库，②为本地库新建origin别名，③初始化本地库git remote -v：查看远程库地址别名git remote add &lt;别名&gt; &lt;远程库地址&gt;：新建远程库地址别名git remote rm &lt;别名&gt;：删除本地中远程库别名git push &lt;别名&gt; &lt;分支名&gt;：本地库某个分支推送到远程库，分支必须指定git pull &lt;别名&gt; &lt;分支名&gt;：把远程库的修改拉取到本地　　tip：该命令包括git fetch，git mergegit fetch &lt;远程库别名&gt; &lt;远程库分支名&gt;：抓取远程库的指定分支到本地，但没有合并git merge &lt;远程库别名/远程库分支名&gt;：将抓取下来的远程的分支，跟当前所在分支进行合并git fork：复制远程库　　tip：一般是外面团队的开发人员fork本团队项目，然后进行开发，之后外面团队发起pull request，然后本团队进行审核，如无问题本团队进行merge（合并）到团队自己的远程库，整个流程就是本团队跟外面团队的协同开发流程，Linux的团队开发成员即为这种工作方式。借用网上的图</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git常用命令&quot;&gt;&lt;a href=&quot;#Git常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令&quot;&gt;&lt;/a&gt;Git常用命令&lt;/h1&gt;&lt;h2 id=&quot;一、本地操作：&quot;&gt;&lt;a href=&quot;#一、本地操作：&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Git" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Git/"/>
    
    
    <category term="Git" scheme="https://hutaozhang.github.io/tags/Git/"/>
    
    <category term="命令" scheme="https://hutaozhang.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Git碰到的坑</title>
    <link href="https://hutaozhang.github.io/posts/7735.html"/>
    <id>https://hutaozhang.github.io/posts/7735.html</id>
    <published>2021-02-03T01:27:43.759Z</published>
    <updated>2021-02-24T17:25:44.810Z</updated>
    
    <content type="html"><![CDATA[<p>凡走过，必留下痕迹。才过的坑，印记更深！！！</p><h3 id="Git-问题"><a href="#Git-问题" class="headerlink" title="Git 问题"></a>Git 问题</h3><ul><li><p>问题：用户名密码正确，但是报错用户名密码错误<br>  <code>remote: Invalid username or password</code><br>  方案:<br>  <a href="https://www.freesion.com/article/8250330335/">https://www.freesion.com/article/8250330335/</a><br>  <a href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token">https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token</a>  </p><p>  <code>error: RPC failed; curl 18 transfer closed with outstanding read data remaining</code><br>  <code>fatal: The remote end hung up unexpectedly</code><br>  方案：<br>  <a href="https://www.cnblogs.com/niudaben/p/12503650.html">https://www.cnblogs.com/niudaben/p/12503650.html</a> 这里http.postBuffer 5242880000</p><p>  <code>error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</code><br>  方案：<br>  <a href="https://blog.csdn.net/lw545034502/article/details/90289437">https://blog.csdn.net/lw545034502/article/details/90289437</a></p></li><li><p>问题：相同分支本地文件与GitHub不一致<br><code>修改文件名大小写后重新提交代码，结果发现git status中并未找到该变化，究其原因是默认git配置了忽略大小写敏感</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git config core.ignorecase</span><br><span class="line">  true</span><br><span class="line">$ git config core.ignorecase false  </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;凡走过，必留下痕迹。才过的坑，印记更深！！！&lt;/p&gt;
&lt;h3 id=&quot;Git-问题&quot;&gt;&lt;a href=&quot;#Git-问题&quot; class=&quot;headerlink&quot; title=&quot;Git 问题&quot;&gt;&lt;/a&gt;Git 问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题：用户名密码正确，但是报错</summary>
      
    
    
    
    <category term="问题" scheme="https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/"/>
    
    <category term="Git" scheme="https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/Git/"/>
    
    
    <category term="Git" scheme="https://hutaozhang.github.io/tags/Git/"/>
    
    <category term="问题" scheme="https://hutaozhang.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 碰到的坑</title>
    <link href="https://hutaozhang.github.io/posts/45533.html"/>
    <id>https://hutaozhang.github.io/posts/45533.html</id>
    <published>2021-02-03T01:27:43.759Z</published>
    <updated>2021-02-24T17:25:44.813Z</updated>
    
    <content type="html"><![CDATA[<p>凡走过，必留下痕迹。才过的坑，印记更深！！！</p><h3 id="Hexo-碰到的坑"><a href="#Hexo-碰到的坑" class="headerlink" title="Hexo 碰到的坑"></a>Hexo 碰到的坑</h3><ol><li><p>box 文件夹下index.html找不到</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    hexo new page box  </span><br><span class="line">    将box的page拷贝过来  </span><br><span class="line">    hexo d  </span><br><span class="line">    &#96;&#96;&#96;  </span><br><span class="line">2. 文件名修改，hexo d 推不上过去  </span><br><span class="line">    Hexo 路径下&#96;deploy_git.git\config&#96; 修改为 &#96;ignorecase &#x3D; false&#96;</span><br></pre></td></tr></table></figure><p> 检查文件名大小写<br> git config core.ignorecase<br> 设置忽略大小写<br> git config core.ignorecase false</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 本地测试与public不一致  </span><br><span class="line">    &#96;hexo s&#96; 生成页面与 &#96;hexo g&#96; 生成页面不一致</span><br></pre></td></tr></table></figure><p> hexo clean<br> hexo server #浏览器打开index.html页面代码<br> hexo g #public下index.htm页面代码不一致 </p><pre><code>两个index.html不一致改变方法解决办法：强行修改ejs文件。</code></pre></li><li><p>部署是分支不正确<br> Hexo 的配置文件_config.yml，已修改branch，但是不起作用<br> 解决办法：修改github默认分支</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;凡走过，必留下痕迹。才过的坑，印记更深！！！&lt;/p&gt;
&lt;h3 id=&quot;Hexo-碰到的坑&quot;&gt;&lt;a href=&quot;#Hexo-碰到的坑&quot; class=&quot;headerlink&quot; title=&quot;Hexo 碰到的坑&quot;&gt;&lt;/a&gt;Hexo 碰到的坑&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;box</summary>
      
    
    
    
    <category term="问题" scheme="https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/"/>
    
    <category term="Hexo" scheme="https://hutaozhang.github.io/categories/%E9%97%AE%E9%A2%98/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hutaozhang.github.io/tags/Hexo/"/>
    
    <category term="问题" scheme="https://hutaozhang.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
