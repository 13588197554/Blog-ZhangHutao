<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术小站</title>
  
  
  <link href="https://hutaozhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://hutaozhang.github.io/"/>
  <updated>2021-05-09T08:04:54.757Z</updated>
  <id>https://hutaozhang.github.io/</id>
  
  <author>
    <name>ZhangHutao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程 - 多线程</title>
    <link href="https://hutaozhang.github.io/posts/53906.html"/>
    <id>https://hutaozhang.github.io/posts/53906.html</id>
    <published>2021-05-09T08:03:46.350Z</published>
    <updated>2021-05-09T08:04:54.757Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多线程的四种创建方式"><a href="#多线程的四种创建方式" class="headerlink" title="多线程的四种创建方式"></a>多线程的四种创建方式</h4><h5 id="一、继承Thread类创建线程"><a href="#一、继承Thread类创建线程" class="headerlink" title="一、继承Thread类创建线程"></a>一、继承Thread类创建线程</h5><p>步骤如下：</p><ol><li><p>定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p></li><li><p>创建Thread子类的实例，也就是创建了线程对象</p></li><li><p>启动线程，即调用线程的start()方法</p></li></ol><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二、实现Runnable接口创建线程"><a href="#二、实现Runnable接口创建线程" class="headerlink" title="二、实现Runnable接口创建线程"></a>二、实现Runnable接口创建线程</h5><p>步骤如下：</p><ol><li><p>定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p></li><li><p>创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p></li><li><p>第三部依然是通过调用线程对象的start()方法来启动线程</p></li></ol><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、使用Callable和Future创建线程"><a href="#三、使用Callable和Future创建线程" class="headerlink" title="三、使用Callable和Future创建线程"></a>三、使用Callable和Future创建线程</h5><ol><li><p>创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p></li><li><p>使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p></li><li><p>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p></li><li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ol><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</span><br><span class="line"></span><br><span class="line">　　  <span class="comment">//使用Lambda表达式创建Callable对象</span></span><br><span class="line">　　 <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> Thread(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子线程的返回值：5</span><br></pre></td></tr></table></figure><h5 id="四、使用线程池，例如用Executor框架"><a href="#四、使用线程池，例如用Executor框架" class="headerlink" title="四、使用线程池，例如用Executor框架"></a>四、使用线程池，例如用Executor框架</h5><blockquote><p>Executor框架这里不做详细介绍<br>详情见**<strong><strong><strong>**</strong></strong></strong><br>一下用三种方式进行实例</p></blockquote><p><strong>1. Executor执行Runnable任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCachedThreadPool</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line"><span class="comment">//      ExecutorService executorService = Executors.newFixedThreadPool(5);  </span></span><br><span class="line"><span class="comment">//      ExecutorService executorService = Executors.newSingleThreadExecutor();  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;   </span><br><span class="line">            executorService.execute(<span class="keyword">new</span> TestRunnable());   </span><br><span class="line">            System.out.println(<span class="string">&quot;************* a&quot;</span> + i + <span class="string">&quot; *************&quot;</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">        executorService.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被调用了。&quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">************* a0 *************</span><br><span class="line">pool-1-thread-1线程被调用了。</span><br><span class="line">************* a1 *************</span><br><span class="line">************* a2 *************</span><br><span class="line">pool-1-thread-3线程被调用了。</span><br><span class="line">************* a3 *************</span><br><span class="line">pool-1-thread-1线程被调用了。</span><br><span class="line">************* a4 *************</span><br><span class="line">pool-1-thread-3线程被调用了。</span><br><span class="line">pool-1-thread-2线程被调用了。</span><br></pre></td></tr></table></figure><p>从结果中可以看出，pool-1-thread-1和pool-1-thread-2均被调用了两次，这是随机的，execute会首先在线程池中选择一个已有空闲线程来执行任务，如果线程池中没有空闲线程，它便会创建一个新的线程来执行任务。</p><p><strong>2. Executor执行Callable任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();   </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//创建10个任务并执行   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;   </span><br><span class="line">            <span class="comment">//使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中   </span></span><br><span class="line">            Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> TaskWithResult(i));   </span><br><span class="line">            <span class="comment">//将任务执行结果存储到List中   </span></span><br><span class="line">            resultList.add(future);   </span><br><span class="line">        &#125;   </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//遍历任务的结果   </span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : resultList)&#123;   </span><br><span class="line">                <span class="keyword">try</span>&#123;   </span><br><span class="line">                    <span class="keyword">while</span>(!fs.isDone);<span class="comment">//Future返回如果没有完成，则一直循环等待，直到Future返回完成  </span></span><br><span class="line">                    System.out.println(fs.get());     <span class="comment">//打印各个线程（任务）执行的结果   </span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;   </span><br><span class="line">                    <span class="comment">//启动一次顺序关闭，执行以前提交的任务，但不接受新任务  </span></span><br><span class="line">                    executorService.shutdown();   </span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 任务的具体过程，一旦任务传给ExecutorService的submit方法， </span></span><br><span class="line"><span class="comment">     * 则该方法自动在一个线程上执行 </span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;call()方法被自动调用！！！    &quot;</span> + Thread.currentThread().getName());   </span><br><span class="line">        <span class="comment">//该返回结果将被Future的get方法得到  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call()方法被自动调用，任务返回的结果是：&quot;</span> + id + <span class="string">&quot;    &quot;</span> + Thread.currentThread().getName();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>3. 自定线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        <span class="comment">//创建等待队列   </span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   </span><br><span class="line">        <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5  </span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   </span><br><span class="line">        <span class="comment">//创建七个任务   </span></span><br><span class="line">        Runnable t1 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t2 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t3 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t4 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t5 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t6 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t7 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        <span class="comment">//每个任务会在一个线程上执行  </span></span><br><span class="line">        pool.execute(t1);   </span><br><span class="line">        pool.execute(t2);   </span><br><span class="line">        pool.execute(t3);   </span><br><span class="line">        pool.execute(t4);   </span><br><span class="line">        pool.execute(t5);   </span><br><span class="line">        pool.execute(t6);   </span><br><span class="line">        pool.execute(t7);   </span><br><span class="line">        <span class="comment">//关闭线程池   </span></span><br><span class="line">        pool.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在执行。。。&quot;</span>);   </span><br><span class="line">        <span class="keyword">try</span>&#123;   </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);   </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;多线程的四种创建方式&quot;&gt;&lt;a href=&quot;#多线程的四种创建方式&quot; class=&quot;headerlink&quot; title=&quot;多线程的四种创建方式&quot;&gt;&lt;/a&gt;多线程的四种创建方式&lt;/h4&gt;&lt;h5 id=&quot;一、继承Thread类创建线程&quot;&gt;&lt;a href=&quot;#一、继承Th</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java/"/>
    
    
    <category term="并发编程" scheme="https://hutaozhang.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程 - Future 和 FutureTask</title>
    <link href="https://hutaozhang.github.io/posts/53768.html"/>
    <id>https://hutaozhang.github.io/posts/53768.html</id>
    <published>2021-05-09T08:03:46.347Z</published>
    <updated>2021-05-09T08:04:54.754Z</updated>
    
    <content type="html"><![CDATA[<p><img src="images/concurrent-programming-futureandfuturetask.jpg" class="lazyload" data-srcset="images/concurrent-programming-futureandfuturetask.jpg" srcset="data:image/png;base64,666" alt="Future 和 FutureTask"></p><h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p><img src="images/concurrent-programming-future.jpg" class="lazyload" data-srcset="images/concurrent-programming-future.jpg" srcset="data:image/png;base64,666" alt="Future"></p><h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><p><img src="images/concurrent-programming-futuretask.jpg" class="lazyload" data-srcset="images/concurrent-programming-futuretask.jpg" srcset="data:image/png;base64,666" alt="FutureTask"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;images/concurrent-programming-futureandfuturetask.jpg&quot; class=&quot;lazyload&quot; data-srcset=&quot;images/concurrent-programming-futureandfut</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java/"/>
    
    
    <category term="并发编程" scheme="https://hutaozhang.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程 - Runnable 和 Callable</title>
    <link href="https://hutaozhang.github.io/posts/57893.html"/>
    <id>https://hutaozhang.github.io/posts/57893.html</id>
    <published>2021-05-09T08:03:46.326Z</published>
    <updated>2021-05-09T08:04:54.737Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h5><p>其中Runnable应该是我们最熟悉的接口，它只有一个run()函数，用于将耗时操作写在其中，该函数没有返回值。然后使用某个线程去执行该runnable即可实现多线程，Thread类在调用start()函数后就是执行的是Runnable的run()函数。Runnable的声明如下 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>Callable 是一个泛型接口，里面只有一个 call() 方法，<strong>该方法可以返回泛型值 V</strong>。Callable的声明如下 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这是一个泛型接口，call()函数返回的类型就是客户程序传递进来的V类型。</p><h5 id="Runnable-与-Runnable-异同"><a href="#Runnable-与-Runnable-异同" class="headerlink" title="Runnable 与 Runnable 异同"></a>Runnable 与 Runnable 异同</h5><p>两个接口都是用于多线程执行任务的，但他们还是有很明显的差别的</p><h6 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h6><ul><li><code>Runnable</code> 既可以用在 Thread 类中，也可以用在 ExecutorService类中配合线程池的使用；</li><li><code>Callable</code> 只能在 ExecutorService 中使用</li></ul><p><strong>Thread</strong><br><img src="images/concurrent-programming-thread.jpg" class="lazyload" data-srcset="images/concurrent-programming-thread.jpg" srcset="data:image/png;base64,666" alt="Thread"></p><p><strong>ExecutorService</strong><br><img src="images/concurrent-programming-executorservice.jpg" class="lazyload" data-srcset="images/concurrent-programming-executorservice.jpg" srcset="data:image/png;base64,666" alt="ExecutorService"></p><h6 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h6><p>Runnable 接口中的 run 方法签名上没有 throws，自然也就没办法向上传播受检异常；而 Callable 的 call() 方法签名却有 throws，所以它可以处理受检异常；</p><p>所以归纳起来看主要有这几处不同点：<br>|       对比        | Runnable | Callable |<br>|:—————–:|:——–:|:——–:|<br>|    方法返回值     |          |    √     |<br>|     异常处理      |          |    √     |<br>|     Thread类      |    √     |          |<br>| ExecutorService类 |    √     |    √     |</p><h5 id="Runnable-和-Callable的使用"><a href="#Runnable-和-Callable的使用" class="headerlink" title="Runnable 和 Callable的使用"></a>Runnable 和 Callable的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个runnable实例</span></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Runnable类型的任务在执行&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Callable实例</span></span><br><span class="line">        Callable&lt;String&gt; c = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Callable类型的任务在执行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;finish&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务到线程池</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        Future&lt;String&gt; cf = service.submit(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Callable的返回值</span></span><br><span class="line">        String resultOfCallable = cf.get();</span><br><span class="line">        </span><br><span class="line">        System.out.println(resultOfCallable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable类型的任务在执行</span><br><span class="line">Callable类型的任务在执行</span><br><span class="line">finish</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;Runnable&quot;&gt;&lt;a href=&quot;#Runnable&quot; class=&quot;headerlink&quot; title=&quot;Runnable&quot;&gt;&lt;/a&gt;Runnable&lt;/h5&gt;&lt;p&gt;其中Runnable应该是我们最熟悉的接口，它只有一个run()函数，用于将耗时操作写在其中</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="并发编程" scheme="https://hutaozhang.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程 - 线程池</title>
    <link href="https://hutaozhang.github.io/posts/36051.html"/>
    <id>https://hutaozhang.github.io/posts/36051.html</id>
    <published>2021-05-09T08:03:46.323Z</published>
    <updated>2021-05-09T08:04:54.732Z</updated>
    
    <content type="html"><![CDATA[<h5 id="线程池基本机制"><a href="#线程池基本机制" class="headerlink" title="线程池基本机制"></a>线程池基本机制</h5><p>线程池是一种池化资源，其主要解决重复创建线程带来的额外开销。线程池的设计使用了生产者-消费者模型。向线程池中提交一个计算任务，执行提交动作的线程是生产者，线程池中的线程作为消费者来执行具体的计算。</p><h5 id="Executor和ExecutorService"><a href="#Executor和ExecutorService" class="headerlink" title="Executor和ExecutorService"></a>Executor和ExecutorService</h5><p>Java中Executor是线程池的顶层抽象接口，其提供了一个最基本的方法定义：执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService拓展了Executor接口，提供了管理线程池、批量执行任务的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><img src="images/concurrent-programming.jpg" class="lazyload" data-srcset="images/concurrent-programming.jpg" srcset="data:image/png;base64,666" alt="ExecutorService"></p><h5 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用静态方法创建一个线程数为固定大小的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个任务</span></span><br><span class="line">        Runnable task = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is execute task&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为ExecutorService拓展了Executor接口因此可以调用execute方法来执行计算任务</span></span><br><span class="line">        pool.execute(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用完线程池之后要主动关闭线程池，销毁线程。</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main] exit</span><br><span class="line">[pool-1-thread-1] is execute task</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;线程池基本机制&quot;&gt;&lt;a href=&quot;#线程池基本机制&quot; class=&quot;headerlink&quot; title=&quot;线程池基本机制&quot;&gt;&lt;/a&gt;线程池基本机制&lt;/h5&gt;&lt;p&gt;线程池是一种池化资源，其主要解决重复创建线程带来的额外开销。线程池的设计使用了生产者-消费者模型。向</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="并发编程" scheme="https://hutaozhang.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程 - 关键字 synchronize</title>
    <link href="https://hutaozhang.github.io/posts/21568.html"/>
    <id>https://hutaozhang.github.io/posts/21568.html</id>
    <published>2021-05-09T08:03:46.299Z</published>
    <updated>2021-05-09T08:04:54.730Z</updated>
    
    <content type="html"><![CDATA[<h5 id="synchronize-机制"><a href="#synchronize-机制" class="headerlink" title="synchronize 机制"></a>synchronize 机制</h5><p>synchronize 是 Java 内置的一种基本的同步机制，synchronize 将Java中的对象当做锁，更具体的说法是：Java中对象的组成中，有一部分叫做对象头，对象头中有锁标志位。synchronize 实际上是操作对象头里面的标志位，从而达到加锁和释放锁的逻辑。</p><h5 id="synchronize-使用"><a href="#synchronize-使用" class="headerlink" title="synchronize 使用"></a>synchronize 使用</h5><p>上面说到，synchronize实际上是作用于Java的对象，因此在实际编程中，有这四种使用synchronize的方式（第三种和第四种实际上为同一类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种，对SynchronizeDemo.class对象加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种，对当前实例加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第三种，对当前实例加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第四种，对指定的实例加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="synchronize-优化"><a href="#synchronize-优化" class="headerlink" title="synchronize 优化"></a>synchronize 优化</h5><p>方法尽量不要直接用一个synchronize锁住，应当减小synchronize的粒度。synchronize 最需要锁住的代码是操作共享变量的代码——即可能导致并发不安全的代码，一些既耗时又是线程安全的代码是没有理由放到同步块中的，降低synchronize的粒度能够增加程序的并发性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;synchronize-机制&quot;&gt;&lt;a href=&quot;#synchronize-机制&quot; class=&quot;headerlink&quot; title=&quot;synchronize 机制&quot;&gt;&lt;/a&gt;synchronize 机制&lt;/h5&gt;&lt;p&gt;synchronize 是 Java 内置的</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="并发编程" scheme="https://hutaozhang.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hutaozhang.github.io/posts/1.html"/>
    <id>https://hutaozhang.github.io/posts/1.html</id>
    <published>2021-05-09T08:03:46.281Z</published>
    <updated>2021-05-09T08:04:55.292Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java源码 多线程 Future</title>
    <link href="https://hutaozhang.github.io/posts/9370.html"/>
    <id>https://hutaozhang.github.io/posts/9370.html</id>
    <published>2021-05-09T08:03:46.278Z</published>
    <updated>2021-05-09T08:04:54.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>别说话，开抄！！！<br>先赞后看，参考一下大神文章：<br><a href="https://blog.csdn.net/u014209205/article/details/80598209" title="JAVA Future类详解">JAVA Future类详解</a></p></blockquote><h3 id="Future的应用场景"><a href="#Future的应用场景" class="headerlink" title="Future的应用场景"></a>Future的应用场景</h3><p>在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。</p><p>Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。</p><p>举个例子：比如去吃早点时，点了包子和凉菜，包子需要等3分钟，凉菜只需1分钟，如果是串行的一个执行，在吃上早点的时候需要等待4分钟，但是因为你在等包子的时候，可以同时准备凉菜，所以在准备凉菜的过程中，可以同时准备包子，这样只需要等待3分钟。那Future这种模式就是后面这种执行模式。</p><h3 id="Future的类图结构"><a href="#Future的类图结构" class="headerlink" title="Future的类图结构"></a>Future的类图结构</h3><p>Future接口定义了主要的5个接口方法，有RunnableFuture和SchedualFuture继承这个接口，以及CompleteFuture和ForkJoinTask继承这个接口。<br><img src="images/java-resource-thread-future.png" class="lazyload" data-srcset="images/java-resource-thread-future.png" srcset="data:image/png;base64,666" alt="Future的类图结构"></p><h5 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h5><p>这个接口同时继承Future接口和Runnable接口，在成功执行run（）方法后，可以通过Future访问执行结果。这个接口都实现类是FutureTask,一个可取消的异步计算，这个类提供了Future的基本实现，后面我们的demo也是用这个类实现，它实现了启动和取消一个计算，查询这个计算是否已完成，恢复计算结果。计算的结果只能在计算已经完成的情况下恢复。如果计算没有完成，get方法会阻塞，一旦计算完成，这个计算将不能被重启和取消，除非调用runAndReset方法。</p><p>        FutureTask能用来包装一个Callable或Runnable对象，因为它实现了Runnable接口，而且它能被传递到Executor进行执行。为了提供单例类，这个类在创建自定义的工作类时提供了protected构造函数。</p><h5 id="SchedualFuture"><a href="#SchedualFuture" class="headerlink" title="SchedualFuture"></a>SchedualFuture</h5><p>这个接口表示一个延时的行为可以被取消。通常一个安排好的future是定时任务SchedualedExecutorService的结果</p><h5 id="CompleteFuture"><a href="#CompleteFuture" class="headerlink" title="CompleteFuture"></a>CompleteFuture</h5><p>一个Future类是显示的完成，而且能被用作一个完成等级，通过它的完成触发支持的依赖函数和行为。当两个或多个线程要执行完成或取消操作时，只有一个能够成功</p><h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>基于任务的抽象类，可以通过ForkJoinPool来执行。一个ForkJoinTask是类似于线程实体，但是相对于线程实体是轻量级的。大量的任务和子任务会被ForkJoinPool池中的真实线程挂起来，以某些使用限制为代价。</p><h3 id="Future的主要方法"><a href="#Future的主要方法" class="headerlink" title="Future的主要方法"></a>Future的主要方法</h3><p>Future接口主要包括5个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get（）</code>方法可以当任务结束后返回一个结果，如果调用时，工作还没有结束，则会阻塞线程，直到任务执行完毕</p><p><code>get（long timeout,TimeUnit unit）</code>做多等待timeout的时间就会返回结果</p><p><code>cancel（boolean mayInterruptIfRunning）</code>方法可以用来停止一个任务，如果任务可以停止（通过mayInterruptIfRunning来进行判断），则可以返回true,如果任务已经完成或者已经停止，或者这个任务无法停止，则会返回false.</p><p><code>isDone（）</code>方法判断当前方法是否完成</p><p><code>isCancel（）</code>方法判断当前方法是否取消</p><h3 id="Future示例demo"><a href="#Future示例demo" class="headerlink" title="Future示例demo"></a>Future示例demo</h3><h5 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h5><ul><li><code>Runnable</code>是一个接口，只声明了一个<code>run()</code>方法，此方法为void类型，所以只能执行无返回值的任务。</li><li><code>Callable</code>是<code>java.util.concurrent</code>包下的一个接口，提供了一个<code>call()</code>方法,该方法返回的数据类型就是传进来的泛型类型，主要用于计算产生结果。如果没有计算出结果，则会抛出异常。</li><li><code>Future</code>则是对于具体的<code>Runnable</code>或<code>Callable</code>任务的执行结果进行取消、判断是否完成、获取任务执行结果。</li><li><code>FutureTask</code>类实现了<code>RunnableFuture</code>接口，而<code>RunnableFuture</code>继承了<code>Runnable</code>和<code>Future</code>接口，可知<code>FutureTask</code>可做<code>Runnable</code>和<code>Future</code>一样的事情。</li></ul><p>注意：<br><em>Runnable 和 Callable 详解见：并发编程-Runnable和Callable</em><br><em>FutureTask中用 Runnable 参数底层也是Callable实现的</em></p><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><p>需求场景：等早餐过程中，包子需要3秒，凉菜需要1秒，普通的多线程需要四秒才能完成。先等凉菜，再等包子，因为等凉菜时，普通多线程启动start()方法，执行run()中具体方法时，没有返回结果，所以如果要等有返回结果，必须是要1秒结束后才知道结果。</p><p><strong>普通多线程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BumThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;包子准备完毕&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDishThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;凉菜准备完毕&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等凉菜 -- 必须要等待返回的结果，所以要调用join方法</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> ColdDishThread();</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等包子 -- 必须要等待返回的结果，所以要调用join方法</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> BumThread();</span><br><span class="line">t2.start();</span><br><span class="line">t2.join();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;准备完毕时间：&quot;</span>+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">凉菜准备完毕</span><br><span class="line">包子准备完毕</span><br><span class="line">准备完毕时间：4015</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>采用Future模式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等凉菜 </span></span><br><span class="line">Callable ca1 = <span class="keyword">new</span> Callable()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;凉菜准备完毕&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;String&gt; ft1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(ca1);</span><br><span class="line"><span class="keyword">new</span> Thread(ft1).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等包子 -- 必须要等待返回的结果，所以要调用join方法</span></span><br><span class="line">Callable ca2 = <span class="keyword">new</span> Callable()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;包子准备完毕&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;String&gt; ft2 = <span class="keyword">new</span> FutureTask&lt;String&gt;(ca2);</span><br><span class="line"><span class="keyword">new</span> Thread(ft2).start();</span><br><span class="line"></span><br><span class="line">System.out.println(ft1.get());</span><br><span class="line">System.out.println(ft2.get());</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;准备完毕时间：&quot;</span>+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">凉菜准备完毕</span><br><span class="line">包子准备完毕</span><br><span class="line">准备完毕时间：3018</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;别说话，开抄！！！&lt;br&gt;先赞后看，参考一下大神文章：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/u014209205/article/details/80598209&quot; title=&quot;JAVA Future类详解&quot;&gt;JA</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="多线程" scheme="https://hutaozhang.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Future" scheme="https://hutaozhang.github.io/tags/Future/"/>
    
  </entry>
  
  <entry>
    <title>TCP 三次握手</title>
    <link href="https://hutaozhang.github.io/posts/3124.html"/>
    <id>https://hutaozhang.github.io/posts/3124.html</id>
    <published>2021-03-11T14:45:37.484Z</published>
    <updated>2021-03-11T14:46:39.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><h5 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h5><p>  <strong>TCP为什么需要三次握手？</strong></p><blockquote><ul><li>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，</li><li>为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</li></ul></blockquote><p>  <strong>TCP三次握手的原因</strong></p><blockquote><ul><li>确定客户端与服务端可以正常接受、发送数据</li><li>防止失效的请求再次传到服务端，造成错误；</li><li>防止网络工攻击：SYN攻击，如DDOS攻讦</li></ul></blockquote><h5 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h5><p>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three.png" srcset="data:image/png;base64,666"><br>  (1) 第一次握手：Client将标志位SYN置为1（表示要发起一个连接），随机产生一个值seq=J，并将该数据包发送给Server，<strong>Client进入SYN_SENT状态</strong>，等待Server确认。</p><p>  (2) 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，<strong>Server进入SYN_RCVD状态</strong>。</p><p>  (3) 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，<strong>Client和Server进入ESTABLISHED状态</strong>，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><h5 id="TCP-三次握手图解"><a href="#TCP-三次握手图解" class="headerlink" title="TCP 三次握手图解"></a>TCP 三次握手图解</h5><ol><li><p>他的本质其实就是要确定客户端和服务端，他们的发送和接收能力是没有问题的。也就是客户端要考察服务端的发送和接收能力，服务端也要考察客户端的发送和接收能力。<br><strong>第一次握手</strong><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-1.png" srcset="data:image/png;base64,666" alt="第一次握手"><br><strong>第二次握手</strong><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-2.png" srcset="data:image/png;base64,666" alt="第二次握手"><br><strong>第三次握手</strong><br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-3.png" srcset="data:image/png;base64,666" alt="第三次握手"></p></li><li><p>防止失效的请求再次传到服务端，造成错误；<br>失效的连接请求是指：主机A发出的连接请求没有收到主机B的确认，过一段时间后，主机A又向主机B发送连接请求，且建立成功，顺序完成数据传输。<br>主机A发送的请求因网络延迟无法到达主机B(并没有丢失)，主机B以为是主机A又发起的新请求，于是主机B同意连接，并向主机A发回确认，但此时主机A根本不理会，导致主机B的资源浪费。</p></li><li><p>防攻击<br>SYN攻击：<br>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：<br><code>#netstat -nap | grep SYN_RECV</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ddos攻击：</span><br><span class="line">分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户&#x2F;服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>TCP报文格式<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-paper.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-three-paper.png" srcset="data:image/png;base64,666" alt="TCP报文格式"><br>(1) 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>(2) 确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。<br>(3) 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<br>  　　（A）URG：紧急指针（urgent pointer）有效。<br>  　　（B）ACK：确认序号有效。<br>  　　（C）PSH：接收方应该尽快将这个报文交给应用层。<br>  　　（D）RST：重置连接。<br>  　　（E）SYN：发起一个新连接。<br>  　　（F）FIN：释放一个连接。  </p><p> 需要注意的是：<br>  （A）不要将确认序号Ack与标志位中的ACK搞混了。<br>  （B）确认方Ack=发起方Req+1，两端配对。</p></li></ul><h4 id="TCP-四次握手"><a href="#TCP-四次握手" class="headerlink" title="TCP 四次握手"></a>TCP 四次握手</h4><p>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-four.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/tcp-four.png" srcset="data:image/png;base64,666" alt="TCP 四次握手"><br>  第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>  第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>  第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>  第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h5 id="为什么是四次挥手"><a href="#为什么是四次挥手" class="headerlink" title="为什么是四次挥手?"></a>为什么是四次挥手?</h5><p>  防止一段数据未发送完。</p><p>  断开连接时，一方收到FIN包，另一方有数据未发送完，此时就需要先向对端回复FIN包的ACK。将剩下的数据发送完后，再像对方发送FIN,断开连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;TCP-三次握手&quot;&gt;&lt;a href=&quot;#TCP-三次握手&quot; class=&quot;headerlink&quot; title=&quot;TCP 三次握手&quot;&gt;&lt;/a&gt;TCP 三次握手&lt;/h4&gt;&lt;h5 id=&quot;问答&quot;&gt;&lt;a href=&quot;#问答&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="TCP" scheme="https://hutaozhang.github.io/tags/TCP/"/>
    
    <category term="三次握手" scheme="https://hutaozhang.github.io/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor-03重要方法</title>
    <link href="https://hutaozhang.github.io/posts/12443.html"/>
    <id>https://hutaozhang.github.io/posts/12443.html</id>
    <published>2021-03-09T13:39:30.148Z</published>
    <updated>2021-03-09T13:39:51.693Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadPoolExecutor中重要方法"><a href="#ThreadPoolExecutor中重要方法" class="headerlink" title="ThreadPoolExecutor中重要方法"></a>ThreadPoolExecutor中重要方法</h4><h5 id="任务提交主逻辑：execute"><a href="#任务提交主逻辑：execute" class="headerlink" title="任务提交主逻辑：execute()"></a>任务提交主逻辑：execute()</h5><details style='background-color:#f9f2f4'>  <summary><font color='#c7254e' size='3px'>execute()源码</font></summary>  <pre>  public void execute(Runnable command) {      if (command == null)          throw new NullPointerException();      /*       * Proceed in 3 steps:       *       * 1. If fewer than corePoolSize threads are running, try to       * start a new thread with the given command as its first       * task.  The call to addWorker atomically checks runState and       * workerCount, and so prevents false alarms that would add       * threads when it shouldn't, by returning false.       *       * 2. If a task can be successfully queued, then we still need       * to double-check whether we should have added a thread       * (because existing ones died since last checking) or that       * the pool shut down since entry into this method. So we       * recheck state and if necessary roll back the enqueuing if       * stopped, or start a new thread if there are none.       *       * 3. If we cannot queue task, then we try to add a new       * thread.  If it fails, we know we are shut down or saturated       * and so reject the task.       */      int c = ctl.get();      if (workerCountOf(c) < corePoolSize) {          if (addWorker(command, true))              return;          c = ctl.get();      }      if (isRunning(c) && workQueue.offer(command)) {          int recheck = ctl.get();          if (! isRunning(recheck) && remove(command))              reject(command);          else if (workerCountOf(recheck) == 0)              addWorker(null, false);      }      else if (!addWorker(command, false))          reject(command);  }  </pre></details><p>以下对execute的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//获取线程池状态</span></span><br><span class="line">        <span class="comment">//第一次启动，默认值是 RUNNING（-536870912） 111 00000 00000000</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// workerCountOf(c) 线程池当前线程数</span></span><br><span class="line">        <span class="comment">// 如果线程池中工作线程数小于核心线程数，则新增一个worker，并结束逻辑执行</span></span><br><span class="line">        <span class="comment">// 如果新增worker失败，更新线程池状态</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING&lt; TERMINATED</span></span><br><span class="line">        <span class="comment">// private static boolean isRunning(int c) &#123;return c &lt; SHUTDOWN;&#125; runinng状态下为true</span></span><br><span class="line">        <span class="comment">// ArrayBlockingQueue.offer()</span></span><br><span class="line">        <span class="comment">// 如果线程池中工作线程数大于核心线程数，则将任务扔到阻塞队列 workQueue 中</span></span><br><span class="line">        <span class="comment">//如果线程池为running状态，并且可以将任务成功添加到workQueue，则创建一个新worker</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">// 如果线程池正在运行，并且成功将任务添加到 workQueue 中</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<span class="comment">// 如果线程池不运行，将任务从workQueue中移除，并执行拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">// 如果线程池运行，并且没有现成在工作，则创建一个新worker</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程池非running状态，或者 任务添加到 workQueue 中失败</span></span><br><span class="line">        <span class="comment">// 并且添加新worker失败，则执行拒绝策略</span></span><br><span class="line">        <span class="comment">// SHUTDOWN状态下，添加worker必然，因为SHUTDOWN不处理新的任务，所以会失败抛出异常</span></span><br><span class="line">        <span class="comment">// SHUTDOWN之上全部会添加失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="添加新线程：addWorker"><a href="#添加新线程：addWorker" class="headerlink" title="添加新线程：addWorker()"></a>添加新线程：addWorker()</h5><details style='background-color:#f9f2f4'>  <summary><font color='#c7254e' size='3px'>addWorker()源码</font></summary>  <pre>    <code>    /**       * Checks if a new worker can be added with respect to current       * pool state and the given bound (either core or maximum). If so,       * the worker count is adjusted accordingly, and, if possible, a       * new worker is created and started, running firstTask as its       * first task. This method returns false if the pool is stopped or       * eligible to shut down. It also returns false if the thread       * factory fails to create a thread when asked.  If the thread       * creation fails, either due to the thread factory returning       * null, or due to an exception (typically OutOfMemoryError in       * Thread.start()), we roll back cleanly.       *       * @param firstTask the task the new thread should run first (or       * null if none). Workers are created with an initial first task       * (in method execute()) to bypass queuing when there are fewer       * than corePoolSize threads (in which case we always start one),       * or when the queue is full (in which case we must bypass queue).       * Initially idle threads are usually created via       * prestartCoreThread or to replace other dying workers.       *       * @param core if true use corePoolSize as bound, else       * maximumPoolSize. (A boolean indicator is used here rather than a       * value to ensure reads of fresh values after checking other pool       * state).       * @return true if successful       */      private boolean addWorker(Runnable firstTask, boolean core) &#123;          retry:          for (;;) &#123;              int c = ctl.get();              int rs = runStateOf(c);<pre><code>          // Check if queue empty only if necessary.          if (rs &gt;= SHUTDOWN &amp;&amp;              ! (rs == SHUTDOWN &amp;&amp;                 firstTask == null &amp;&amp;                 ! workQueue.isEmpty()))              return false;          for (;;) &#123;              int wc = workerCountOf(c);              if (wc &gt;= CAPACITY ||                  wc &gt;= (core ? corePoolSize : maximumPoolSize))                  return false;              if (compareAndIncrementWorkerCount(c))                  break retry;              c = ctl.get();  // Re-read ctl              if (runStateOf(c) != rs)                  continue retry;              // else CAS failed due to workerCount change; retry inner loop          &#125;      &#125;      boolean workerStarted = false;      boolean workerAdded = false;      Worker w = null;      try &#123;          w = new Worker(firstTask);          final Thread t = w.thread;          if (t != null) &#123;              final ReentrantLock mainLock = this.mainLock;              mainLock.lock();              try &#123;                  // Recheck while holding lock.                  // Back out on ThreadFactory failure or if                  // shut down before lock acquired.                  int rs = runStateOf(ctl.get());                  if (rs &lt; SHUTDOWN ||                      (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;                      if (t.isAlive()) // precheck that t is startable                          throw new IllegalThreadStateException();                      workers.add(w);                      int s = workers.size();                      if (s &gt; largestPoolSize)                          largestPoolSize = s;                      workerAdded = true;                  &#125;              &#125; finally &#123;                  mainLock.unlock();              &#125;              if (workerAdded) &#123;                  t.start();                  workerStarted = true;              &#125;          &#125;      &#125; finally &#123;          if (! workerStarted)              addWorkerFailed(w);      &#125;      return workerStarted;  &#125;&lt;/code&gt;</code></pre><p>  </pre></p></details><p>以下是对addWorker的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ThreadPoolExecutor中重要方法&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor中重要方法&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor中重要方法&quot;&gt;&lt;/a&gt;ThreadPoolExecuto</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor-02构造函数</title>
    <link href="https://hutaozhang.github.io/posts/52671.html"/>
    <id>https://hutaozhang.github.io/posts/52671.html</id>
    <published>2021-03-09T13:39:30.145Z</published>
    <updated>2021-03-09T13:39:51.696Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadPoolExecutor中的构造函数"><a href="#ThreadPoolExecutor中的构造函数" class="headerlink" title="ThreadPoolExecutor中的构造函数"></a>ThreadPoolExecutor中的构造函数</h4><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>)</h5><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-RejectedExecutionHandler"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-RejectedExecutionHandler" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue, RejectedExecutionHandler)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>, RejectedExecutionHandler)</h5><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue, ThreadFactory)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>, ThreadFactory)</h5><h5 id="ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory-RejectedExecutionHandler"><a href="#ThreadPoolExecutor-int-int-long-TimeUnit-BlockingQueue-ThreadFactory-RejectedExecutionHandler" class="headerlink" title="ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue, ThreadFactory, RejectedExecutionHandler)"></a>ThreadPoolExecutor(int, int, long, TimeUnit, BlockingQueue<Runnable>, ThreadFactory, RejectedExecutionHandler)</h5>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> :  AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize  线程池核心线程数量</li><li>maximumPoolSize 线程池最大数量</li><li>keepAliveTime  空闲线程存活时间</li><li>unit 时间单位</li><li>workQueue 线程池所使用的缓冲队列</li><li>threadFactory 线程池创建线程使用的工厂</li><li>handler  线程池对拒绝任务的处理策略</li></ul><p>  <strong>corePoolSize</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ThreadPoolExecutor中的构造函数&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor中的构造函数&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor中的构造函数&quot;&gt;&lt;/a&gt;ThreadPoolExec</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor-01成员变量</title>
    <link href="https://hutaozhang.github.io/posts/31498.html"/>
    <id>https://hutaozhang.github.io/posts/31498.html</id>
    <published>2021-03-09T13:39:30.142Z</published>
    <updated>2021-03-09T13:39:51.686Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ThreadPoolExecutor中的重要成员变量"><a href="#ThreadPoolExecutor中的重要成员变量" class="headerlink" title="ThreadPoolExecutor中的重要成员变量"></a>ThreadPoolExecutor中的重要成员变量</h4><h5 id="AtomicInteger-ctl"><a href="#AtomicInteger-ctl" class="headerlink" title="AtomicInteger ctl"></a>AtomicInteger <code>ctl</code></h5>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>  AtomicInteger类型的ctl代表了ThreadPoolExecutor中的控制状态，它是一个复核类型的成员变量，是一个原子整数，借助高低位包装了两个概念：</p><p>  (1) <code>workerCount</code>：线程池中当前活动的线程数量，占据ctl的<font color=blue><strong><em>低29位</em></strong></font>；</p><p>  (2) <code>runState</code>：线程池运行状态，占据<code>ctl</code>的<font color=red><strong>高3位</strong></font>，有<code>RUNNING</code>、<code>SHUTDOWN</code>、<code>STOP</code>、<code>TIDYING</code>、<code>TERMINATED</code>五种状态。</p><blockquote><p>如下，红色为高3位，蓝色为低29位，共32位<br><font color=red>000</font> <font color=blue><strong><em>00000 00000000 00000000 00000000</em></strong></font></p></blockquote><p>  <strong>workerCount</strong><br>  workerCount 代表线程池中当前活动的线程数量，每当活跃线程数增加或减少时，<code>ctl</code>直接做相应数目的增减即可，十分方便。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>  <code>COUNT_BITS</code>: 代表了workerCount所占位数为29 （<code>Integer.SIZE</code>为32）<br>  <code>CAPACITY</code>: 代表workerCount最大值为536870911 (<code>(2^29)-1</code>)  </p><blockquote><p>位运算：1 &lt;&lt; COUNT_BITS<br>1 = 2^0 为  00000000 00000000 00000000 00000001<br>左移29位结果如下<br>00000000 00000000 00000000 00000001 –&gt; 001 0000 00000000 00000000 00000000</p></blockquote><p>  <strong>runState</strong><br>  runState 代表线程池运行状态：<code>RUNNING</code>(-536870912)、<code>SHUTDOWN</code>(0)、<code>STOP</code>(536870912)、<code>TIDYING</code>(1073741824)、<code>TERMINATED</code>(1610612736)<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// -1在Java底层是由32个1表示的，左移29为：111 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 0在Java底层是由32个0表示的，左移29为：000 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 1在Java底层是由前31个0加1个1表示的，左移29为：001 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 2在Java底层是由前30个0加1个10表示的，左移29为：010 00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 3在Java底层是由前30个0加1个11表示的，左移29为：011 00000 00000000 00000000 00000000</span></span><br></pre></td></tr></table></figure></p><ul><li><code>RUNNING</code>(-536870912)：接受新任务，并处理队列任务</li><li><code>SHUTDOWN</code>(0)：不接受新任务，但会处理队列任务</li><li><code>STOP</code>(536870912)：不接受新任务，不会处理队列任务，而且会中断正在处理过程中的任务</li><li><code>TIDYING</code>(1073741824)：所有的任务已结束，workerCount为0，线程过渡到TIDYING状态，将会执行terminated()钩子方法</li><li><code>TERMINATED</code>(1610612736)：terminated()方法已经完成</li></ul><p>  <strong>NOTE：状态值大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING&lt; TERMINATED</strong></p><p>  <strong><em>状态转化：</em></strong></p><ol><li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法后，或者线程池实现了finalize方法，在里面调用了shutdown方法，即隐式调用；</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()方法后；</li><li>SHUTDOWN -&gt; TIDYING：线程池和队列均为空时；</li><li>STOP -&gt; TIDYING：线程池为空时；</li><li>TIDYING -&gt; TERMINATED：terminated()钩子方法完成时。</li></ol><p>  <strong>runStateOf()</strong><br>   <code>runStateOf(int c)</code>运行状态<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>~ 是按位取反的意思，CAPACITY表示的是高位的3个0，和低位的29个1，而~CAPACITY则表示高位的3个1，低位的29个0<br>~CAPACITY: 111 0000 00000000 00000000 00000000<br>&amp; 是与操作，入参c执行按位与操作，即高3位保持原样，低29位全部设置为0，也就获取了线程池的运行状态runState。</p></blockquote><p>  <strong>workerCountOf()</strong><br>  <code>workerCountOf(int c)</code>计算线程池当前线程数<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>~ 是按位取反的意思，CAPACITY表示的是高位的3个0，和低位的29个1，而~CAPACITY则表示高位的3个1，低位的29个0<br>~CAPACITY: 111 0000 00000000 00000000 00000000<br>&amp; 是与操作，入参c执行按位与操作，即高3位保持原样，低29位全部设置为0，也就获取了线程池的运行状态runState。</p></blockquote><p>  <strong>ctlOf()</strong><br>  <code>ctlOf(int rs, int wc)</code>初始化ctl<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>rs表示线程池运行状态runState，其是高3位有值，低29位全部为0的int<br>wc则代表线程池中有效线程的数量workerCount，其为高3位全部为0，而低29位有值得int<br>| 是 <strong>或</strong> 操作，，即用runState的高3位，workerCount的低29位填充的数字，而默认传入的runState、workerCount分别为RUNNING和0</p></blockquote><h5 id="BlockingQueue-lt-Runnable-gt-workQueue"><a href="#BlockingQueue-lt-Runnable-gt-workQueue" class="headerlink" title="BlockingQueue&lt;Runnable&gt; workQueue"></a><code>BlockingQueue&lt;Runnable&gt; workQueue</code></h5><p>   workQueue是用于持有任务并将其转换成工作线程worker的队列；</p><h5 id="HashSet-lt-Worker-gt-workers"><a href="#HashSet-lt-Worker-gt-workers" class="headerlink" title="HashSet&lt;Worker&gt; workers"></a><code>HashSet&lt;Worker&gt; workers</code></h5><p>   workers是包含线程池中所有工作线程worker的集合，仅仅当拥有mainLock锁时才能访问它；</p><h5 id="long-completedTaskCount"><a href="#long-completedTaskCount" class="headerlink" title="long completedTaskCount"></a><code>long completedTaskCount</code></h5><p>   completedTaskCount是已完成任务的计数器，只有在worker线程的终止，仅仅当拥有mainLock锁时才能访问它；</p><h5 id="volatile-ThreadFactory-threadFactory"><a href="#volatile-ThreadFactory-threadFactory" class="headerlink" title="volatile ThreadFactory threadFactory"></a><code>volatile ThreadFactory threadFactory</code></h5><p>   创建新线程的工厂类；</p><h5 id="volatile-RejectedExecutionHandler-handler"><a href="#volatile-RejectedExecutionHandler-handler" class="headerlink" title="volatile RejectedExecutionHandler handler"></a><code>volatile RejectedExecutionHandler handler</code></h5><p>   执行过程中shutdown时调用的handler；</p><h5 id="volatile-long-keepAliveTime"><a href="#volatile-long-keepAliveTime" class="headerlink" title="volatile long keepAliveTime"></a><code>volatile long keepAliveTime</code></h5><p>   空闲线程等待工作的超时时间（纳秒），即空闲线程存活时间；</p><h5 id="volatile-boolean-allowCoreThreadTimeOut"><a href="#volatile-boolean-allowCoreThreadTimeOut" class="headerlink" title="volatile boolean allowCoreThreadTimeOut"></a><code>volatile boolean allowCoreThreadTimeOut</code></h5><p>   默认值为false，如果为false，core线程在空闲时依然存活；如果为true，则core线程等待工作，直到时间超时至keepAliveTime；</p><h5 id="volatile-int-corePoolSize"><a href="#volatile-int-corePoolSize" class="headerlink" title="volatile int corePoolSize"></a><code>volatile int corePoolSize</code></h5><p>   核心线程池大小，保持存活的工作线程的最小数目，当小于corePoolSize时，会直接启动新的一个线程来处理任务，而不管线程池中是否有空闲线程；</p><h5 id="volatile-int-maximumPoolSize"><a href="#volatile-int-maximumPoolSize" class="headerlink" title="volatile int maximumPoolSize"></a><code>volatile int maximumPoolSize</code></h5><p>   线程池最大大小，也就是线程池中线程的最大数量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ThreadPoolExecutor中的重要成员变量&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor中的重要成员变量&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor中的重要成员变量&quot;&gt;&lt;/a&gt;ThreadPo</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java源码-ThreadPoolExecutor</title>
    <link href="https://hutaozhang.github.io/posts/36639.html"/>
    <id>https://hutaozhang.github.io/posts/36639.html</id>
    <published>2021-03-09T13:39:30.139Z</published>
    <updated>2021-05-09T08:04:07.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>别说话，开抄！！！<br>先赞后看，参考一下大神文章：<br><a href="https://blog.csdn.net/lipeng_bigdata/article/details/51232266" title="ThreadPoolExecutor源码分析（一）：重要成员变量">ThreadPoolExecutor源码分析（一）：重要成员变量</a><br><a href="http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" title="ThreadPoolExecutor源码分析（一）：重要成员变量">深入理解Java线程池：ThreadPoolExecutor</a></p></blockquote><h3 id="ThreadPoolExecutor-Demo"><a href="#ThreadPoolExecutor-Demo" class="headerlink" title="ThreadPoolExecutor Demo"></a>ThreadPoolExecutor Demo</h3><p>  没看过源码，写个Demo压压惊~<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"> <span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//自定义线程池</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>);</span><br><span class="line"> ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, queue);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line"> MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line"> pool.execute(myTask);</span><br><span class="line"> System.out.println(<span class="string">&quot;线程池中的线程数目：&quot;</span>+pool.getPoolSize()+<span class="string">&quot;,队列中等待执行的任务数量：&quot;</span>+pool.getQueue().size()+<span class="string">&quot;,已执行完的任务数目：&quot;</span>+pool.getCompletedTaskCount());</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> pool.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;正在执行task &quot;</span> + taskNum);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;task &quot;</span>+taskNum+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程图结构关系"><a href="#线程图结构关系" class="headerlink" title="线程图结构关系"></a>线程图结构关系</h3><ul><li><p><strong>线程池总图</strong><br><img src="java-resource-threadpool-all.png" class="lazyload" data-srcset="java-resource-threadpool-all.png" srcset="data:image/png;base64,666"></p></li><li><p><strong>ThreadPoolExecutor 继承关系</strong><br><img src="java-resource-threapoolexecutor.png" class="lazyload" data-srcset="java-resource-threapoolexecutor.png" srcset="data:image/png;base64,666"></p></li><li><p><strong>ThreadPoolExecutor 源码</strong>  </p><a href="/posts/31498.html" title="Java源码-ThreadPoolExecutor-01成员变量">Java源码-ThreadPoolExecutor-01成员变量</a> <a href="/posts/52671.html" title="Java源码-ThreadPoolExecutor-02构造函数">Java源码-ThreadPoolExecutor-02构造函数</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;别说话，开抄！！！&lt;br&gt;先赞后看，参考一下大神文章：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/lipeng_bigdata/article/details/51232266&quot; title=&quot;ThreadPoolExec</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="https://hutaozhang.github.io/tags/Java%E6%BA%90%E7%A0%81/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://hutaozhang.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>面试 Database 基础</title>
    <link href="https://hutaozhang.github.io/posts/25491.html"/>
    <id>https://hutaozhang.github.io/posts/25491.html</id>
    <published>2021-03-08T13:42:08.741Z</published>
    <updated>2021-03-08T13:47:45.838Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么使用数据库？"><a href="#为什么使用数据库？" class="headerlink" title="为什么使用数据库？"></a>为什么使用数据库？</h5><ul><li><p>数据保存在内存</p><p>优点： 存取速度快</p><p>缺点： 数据不能永久保存</p></li><li><p>数据保存在文件</p><p>优点： 数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p></li><li><p>数据保存在数据库</p><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p></li></ul><h5 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h5><p>  结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><p>  作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h5 id="什么是MYSQL"><a href="#什么是MYSQL" class="headerlink" title="什么是MYSQL?"></a>什么是MYSQL?</h5><p>  MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。<br>  MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h5 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h5><ul><li><p>第一范式：每个列都不可以再拆分。</p></li><li><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p></li><li><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p></li></ul><h5 id="MySQL有关权限的表都有哪几个？"><a href="#MySQL有关权限的表都有哪几个？" class="headerlink" title="MySQL有关权限的表都有哪几个？"></a>MySQL有关权限的表都有哪几个？</h5><p>  MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。<br>  这些权限表分别<code>user</code>，<code>db</code>，<code>table_priv</code>，<code>columns_priv和host</code>。下面分别介绍一下这些表的结构和内容：</p><ol><li><code>user</code>权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li><code>db</code>权限表：记录各个帐号在各个数据库上的操作权限。</li><li><code>table_priv</code>权限表：记录数据表级的操作权限。</li><li><code>columns_priv</code>权限表：记录数据列级的操作权限。</li><li><code>host</code>权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ol><h5 id="MySQL中binlog有几种录入模式？分别有什么区别？"><a href="#MySQL中binlog有几种录入模式？分别有什么区别？" class="headerlink" title="MySQL中binlog有几种录入模式？分别有什么区别？"></a>MySQL中binlog有几种录入模式？分别有什么区别？</h5><p>  有三种格式: <code>statement</code>, <code>row</code> 和 <code>mixed</code>。</p><ol><li><p><code>statement</code>模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</p></li><li><p><code>row</code>级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</p></li><li><p><code>mixed</code>，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</p><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p></li></ol><h5 id="MySQL支持哪些数据类型？"><a href="#MySQL支持哪些数据类型？" class="headerlink" title="MySQL支持哪些数据类型？"></a>MySQL支持哪些数据类型？</h5><p>  1、<strong>整数类型</strong>，包括<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p><p>  长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p><p>  例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p><p>  2、<strong>实数类型</strong><br>  <code>FLOAT</code>、<code>DOUBLE</code>、<code>DECIMAL</code></p><p>  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。</p><p>  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。</p><p>  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p><p>  3、<strong>字符串类型</strong><br>  <code>VARCHAR</code>、<code>CHAR</code>、<code>TEXT</code>、<code>BLOB</code></p><p>  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</p><p>  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</p><p>  VARCHAR存储的内容超出设置的长度时，内容会被截断。</p><p>  CHAR是定长的，根据定义的字符串长度分配足够的空间。</p><p>  CHAR会根据需要使用空格进行填充方便比较。</p><p>  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</p><p>  CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p>  <strong>使用策略：</strong><br>  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。  </p><p>  4、<strong>枚举类型</strong><br>  <code>ENUM</code>，把不重复的数据存储为一个预定义的集合。 </p><p>  有时可以使用ENUM代替常用的字符串类型。 </p><p>  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</p><p>  ENUM在内部存储时，其实存的是整数。</p><p>  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</p><p>  排序是按照内部存储的整数  </p><p>  5、<strong>日期和时间类型</strong><br>  <code>timestamp</code> <code>datetime</code><br>  尽量使用<code>timestamp</code>，空间效率高于<code>datetime</code></p><p>  用整数保存时间戳通常不方便处理。</p><p>  如果需要存储微妙，可以使用bigint存储。</p><p>  看到这里，这道真题是不是就比较容易回答了。 </p><h5 id="MySQL存储引擎有哪些？他们有什么区别？"><a href="#MySQL存储引擎有哪些？他们有什么区别？" class="headerlink" title="MySQL存储引擎有哪些？他们有什么区别？"></a>MySQL存储引擎有哪些？他们有什么区别？</h5><p>  存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>  常用的存储引擎有以下：</p><ul><li><p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p></li><li><p><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</p></li><li><p><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p><p>区别详情见： <a href="#form1">MyISAM与InnoDB区别</a></p></li></ul><h5 id="MySQL中MyISAM索引与InnoDB索引有什么区别？"><a href="#MySQL中MyISAM索引与InnoDB索引有什么区别？" class="headerlink" title="MySQL中MyISAM索引与InnoDB索引有什么区别？"></a>MySQL中MyISAM索引与InnoDB索引有什么区别？</h5><ul><li><p>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</p></li><li><p>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</p></li><li><p>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</p></li><li><p>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p></li></ul><h5 id="MySQL中InnoDB引擎的特性"><a href="#MySQL中InnoDB引擎的特性" class="headerlink" title="MySQL中InnoDB引擎的特性?"></a>MySQL中InnoDB引擎的特性?</h5><ul><li><p>插入缓冲（insert buffer)</p></li><li><p>二次写(double write)</p></li><li><p>自适应哈希索引(ahi)</p></li><li><p>预读(read ahead)</p></li></ul><h5 id="存储引擎的选择？"><a href="#存储引擎的选择？" class="headerlink" title="存储引擎的选择？"></a>存储引擎的选择？</h5><p>  如果没有特别的需求，使用默认的Innodb即可。</p><ul><li><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p></li><li><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p></li></ul><hr><h5 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h5><p><em>表单一： <a id="form1">MyISAM与InnoDB区别</a></em></p><table><thead><tr><th align="center"></th><th align="center">MyISAM</th><th align="center">Innodb</th></tr></thead><tbody><tr><td align="center">存储结构</td><td align="center">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td align="center">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td align="center">存储空间</td><td align="center">MyISAM可被压缩，存储空间较小</td><td align="center">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td align="center">可移植性、备份及恢复</td><td align="center">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td align="center">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td align="center">文件格式</td><td align="center">数据和索引是分别存储的，数据.MYD，索引.MYI</td><td align="center">数据和索引是集中存储的，.ibd</td></tr><tr><td align="center">记录存储顺序</td><td align="center">按记录插入顺序保存</td><td align="center">按主键大小有序插入</td></tr><tr><td align="center">外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">锁支持（锁是避免资源争用的一个机制，<br>MySQL锁对用户几乎是透明的）</td><td align="center">表级锁定</td><td align="center">行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td align="center">SELECT</td><td align="center">MyISAM更优</td><td align="center"></td></tr><tr><td align="center">NSERT、UPDATE、DELETE</td><td align="center"></td><td align="center">InnoDB更优</td></tr><tr><td align="center">select count(*)</td><td align="center">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td align="center"></td></tr><tr><td align="center">索引的实现方式</td><td align="center">B+树索引，myisam 是堆表</td><td align="center">B+树索引，Innodb 是索引组织表</td></tr><tr><td align="center">哈希索引</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;为什么使用数据库？&quot;&gt;&lt;a href=&quot;#为什么使用数据库？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用数据库？&quot;&gt;&lt;/a&gt;为什么使用数据库？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据保存在内存&lt;/p&gt;
&lt;p&gt;优点： 存取速度快&lt;/p&gt;
&lt;p&gt;缺</summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/"/>
    
    
    <category term="Database" scheme="https://hutaozhang.github.io/tags/Database/"/>
    
    <category term="基础" scheme="https://hutaozhang.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务</title>
    <link href="https://hutaozhang.github.io/posts/40486.html"/>
    <id>https://hutaozhang.github.io/posts/40486.html</id>
    <published>2021-03-08T11:05:45.244Z</published>
    <updated>2021-03-08T11:54:04.778Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h3><p>  Spring事务本质是对数据库事务的支持，如果数据库不支持事务（例如MySQL的MyISAM引擎不支持事务），则Spring事务也不会生效。</p><p>  Spring 既支持<font color=red>编程式事务管理</font>, 也支持<font color=red>声明式的事务管理</font>.</p><ul><li>编程式事务管理<br>将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码。</li></ul><ul><li>声明式的事务管理<br>它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。事务管理作为一种横切关注点, 可以通过 AOP 方法模块化。Spring 通过 Spring AOP 框架支持声明式事务管理。</li></ul><p>  <strong>Spring事务管理</strong><br>  Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。</p><p>  Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><p>  <em>SSM中，一般spring自己管理事务，属于声明式管理，如果让MyBatis来管理事务，会导致api形式的调用，也就是编程式事务。</em></p><p>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-structure.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-structure.png" srcset="data:image/png;base64,666" alt="Spring事务结构图"></p><p>  此接口的内容如下：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line"><span class="comment">// 由TransactionDefinition得到TransactionStatus对象</span></span><br><span class="line"> <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line"> <span class="comment">// 提交</span></span><br><span class="line"> <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line"> <span class="comment">// 回滚</span></span><br><span class="line"> <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><br>  从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。</p><p>  运行流程示例如下：<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-running.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/spring-transaction-running.png" srcset="data:image/png;base64,666" alt="Spring事务运行流程图"></p><h4 id="事务管理器的不同实现"><a href="#事务管理器的不同实现" class="headerlink" title="事务管理器的不同实现"></a>事务管理器的不同实现</h4><p>  ① DataSourceTransactionManager<br>  在应用程序中只需要处理一个数据源，而且通过JDBC存取。<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>     </span></span><br><span class="line"><span class="tag">   <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p><p>  ② JtaTransactionManager<br>  在JAVAEE应用服务器上用JTA(Java Transaction API)进行事务管理。</p><p>  ③ HibernateTransactionManager<br>  如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。</p><p>  对于Hibernate3，需要在Spring上下文定义中添加如下的<code>&lt;bean&gt;</code>声明：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。</p><p>  当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p><h4 id="声明式的事务管理"><a href="#声明式的事务管理" class="headerlink" title="声明式的事务管理"></a>声明式的事务管理</h4><p>  事务管理是一种横切关注点</p><p>  ① <code>&lt;tx:advice&gt;</code> 元素定义<br>  为了在 Spring 2.x 中启用声明式事务管理, 可以通过 tx Schema 中定义的 <code>&lt;tx:advice&gt;</code> 元素声明事务通知, 为此必须事先将这个 Schema 定义添加到 <code>&lt;beans&gt;</code> 根元素中去。<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据方法名指定事务的属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;purchase&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  ② 声明了事务通知后, 就需要将它与切入点关联起来.<br>  由于事务通知是在 <a href="aop:config">aop:config</a> 元素外部声明的, 所以它无法直接与切入点产生关联. 所以必须在<a href="aop:config">aop:config</a> 元素中声明一个增强器通知与切入点关联起来.<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>  由于 Spring AOP 是基于代理的方法, 所以只能增强公共方法. 因此, 只有公有方法才能通过 Spring AOP 进行事务管理。</p><h3 id="Spring事务传播"><a href="#Spring事务传播" class="headerlink" title="Spring事务传播"></a>Spring事务传播</h3><p>  事务传播行为是指一个事务方法A被另一个事务方法B调用时，这个事务A应该如何处理。事务A应该在事务B中运行还是另起一个事务，这个有事务A的传播行为决定。</p><p>  事务传播属性定义<code>TransactionDefinition</code><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th align="left">常量名称</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">PROPAGATION_REQUIRED</td><td align="left">支持当前事务，如果当前没有事务，就新建一个事务。这是Spring 默认的事务的传播。</td></tr><tr><td align="left">PROPAGATION_SUPPORTS</td><td align="left">支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td align="left">PROPAGATION_MANDATORY</td><td align="left">支持当前事务，如果当前没有事务，就抛出异常。</td></tr><tr><td align="left">PROPAGATION_REQUIRES_NEW</td><td align="left">新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后， 不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获， 也可以不处理回滚操作。 使用JtaTransactionManager作为事务管理器</td></tr><tr><td align="left">PROPAGATION_NOT_SUPPORTED</td><td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。使用JtaTransactionManager作为事务管理器</td></tr><tr><td align="left">PROPAGATION_NEVER</td><td align="left">以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td align="left">PROPAGATION_NESTED</td><td align="left">如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</td></tr></tbody></table><ul><li><strong>PROPAGATION_REQUIRED</strong>  </li><li>PROPAGATION_SUPPORTS</li><li>PROPAGATION_MANDATORY</li><li>PROPAGATION_REQUIRES_NEW</li><li>PROPAGATION_NOT_SUPPORTED</li><li>PROPAGATION_NEVER</li><li>PROPAGATION_NESTED</li></ul><h3 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h3><p>  事务隔离级别定义<code>TransactionDefinition</code><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><br>|           隔离级别           |                                                         解释                                                          |<br>|:————————–:|:———————————————————————————————————————–:|<br>|     ISOLATION_DEFAULT      |  这是个 PlatfromTransactionManager 默认的隔离级别， 使用数据库默认的事务隔离级别。另外四个与 JDBC 的 隔离级别相对应。   |<br>| ISOLATION_READ_UNCOMMITTED | 这是事务最低的隔离级别，它允许另外一个事务可以看 到这个事务未提交的数据。这种隔离级别会产生脏读， 不可重复读和幻像读。  |<br>|  ISOLATION_READ_COMMITTED  | 保证一个事务修改的数据提交后才能被另外一个事务读 取。另外一个事务不能读取该事务未提交的数据。 ISOLATION_REPEATABLE_READ |<br>|   ISOLATION_SERIALIZABLE   | 这是花费最高代价但是最可靠的事务隔离级别。事务被 处理为顺序执行。                                                                                                                        |</p><h3 id="Spring事务基本配置样例"><a href="#Spring事务基本配置样例" class="headerlink" title="Spring事务基本配置样例"></a>Spring事务基本配置样例</h3>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;transactionAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception,RuntimeException,SQLException&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception,RuntimeException,SQLException&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;edit*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception,RuntimeException,SQLException&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;NOT_SUPPORTED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;transactionAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;transactionPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;transactionPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public * com.gupaoedu..*.service..*Service.*(..))&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;Spring的事务管理&quot;&gt;&lt;a href=&quot;#Spring的事务管理&quot; class=&quot;headerlink&quot; title=&quot;Spring的事务管理&quot;&gt;&lt;/a&gt;Spring的事务管理&lt;/h3&gt;&lt;p&gt;  Spring事务本质是对数据库事务的支</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Spring" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Spring/"/>
    
    
    <category term="事务" scheme="https://hutaozhang.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="Transaction" scheme="https://hutaozhang.github.io/tags/Transaction/"/>
    
    <category term="Spring" scheme="https://hutaozhang.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://hutaozhang.github.io/posts/63394.html"/>
    <id>https://hutaozhang.github.io/posts/63394.html</id>
    <published>2021-03-07T09:54:35.889Z</published>
    <updated>2021-03-08T11:05:13.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><a href="/posts/46219.html" title="Database 事务">Database 事务</a>  <a href="/posts/45033.html" title="Database 事务ACID特性">Database 事务ACID特性</a>  <a href="/posts/40486.html" title="Spring 事务">Spring 事务</a>  <a href="/posts/29528.html" title="面试 MySQL 事务">面试 MySQL 事务</a><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><a href="/posts/58986.html" title="MySQL 索引">MySQL 索引</a><a href="/posts/43567.html" title="面试 MySQL 索引">面试 MySQL 索引</a><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><a href="/posts/2460.html" title="面试 MySQL MVCC">面试 MySQL MVCC</a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h4&gt;&lt;a</summary>
      
    
    
    
    
    <category term="数据库" scheme="https://hutaozhang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引</title>
    <link href="https://hutaozhang.github.io/posts/58986.html"/>
    <id>https://hutaozhang.github.io/posts/58986.html</id>
    <published>2021-03-06T14:01:00.941Z</published>
    <updated>2021-03-08T10:02:48.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、索引概述"><a href="#一、索引概述" class="headerlink" title="一、索引概述"></a>一、索引概述</h3><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h5><h5 id="2-索引的原理"><a href="#2-索引的原理" class="headerlink" title="2. 索引的原理"></a>2. 索引的原理</h5><p>  MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>  只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>  FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建表的时候添加FULLTEXT索引</span><br><span class="line">CTREATE <span class="keyword">TABLE</span> my_table(</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    my_text TEXT,</span><br><span class="line">    FULLTEXT(my_text)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建表以后，在需要的时候添加FULLTEXT索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ADD</span> FULLTEXT INDEX ft_index(column_name);</span><br></pre></td></tr></table></figure><br>  全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">MATCH</span>(ft_index) AGAINST(<span class="string">&#x27;查询字符串&#x27;</span>);</span><br></pre></td></tr></table></figure></p><h5 id="BTree索引和B-Tree索引"><a href="#BTree索引和B-Tree索引" class="headerlink" title="BTree索引和B+Tree索引"></a>BTree索引和B+Tree索引</h5><ul><li><p>BTree索引</p><ul><li>BTree是平衡搜索多叉树，设树的度为2d（d&gt;1），高度为h，那么BTree要满足以一下条件：</li><li>每个叶子结点的高度一样，等于h；</li><li>每个非叶子结点由n-1个key和n个指针point组成，其中d&lt;=n&lt;=2d,key和point相互间隔，结点两端一定是key；</li><li>叶子结点指针都为null；</li><li>非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；</li></ul><p>BTree的结构如下：<br><img src="mysql-index-btree.png" class="lazyload" data-srcset="mysql-index-btree.png" srcset="data:image/png;base64,666" alt="BTree结构"><br>在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。</p></li><li><p>B+Tree索引<br>B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：</p><ul><li>B+Tree中的非叶子结点不存储数据，只存储键值；</li><li>B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；</li><li>B+Tree的每个非叶子节点由n个键值key和n个指针point组成；</li></ul><p>B+Tree的结构图如下：<br><img src="mysql-index-b+tree.png" class="lazyload" data-srcset="mysql-index-b+tree.png" srcset="data:image/png;base64,666" alt="B+Tree结构"></p></li></ul><p>  <strong>B+Tree对比BTree的优点：</strong><br>  1、磁盘读写代价更低<br>  一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p><p>  2、查询速度更稳定<br>  由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。</p><ul><li><p>带顺序索引的B+Tree<br>很多存储引擎在B+Tree的基础上进行了优化，添加了指向相邻叶节点的指针，形成了带有顺序访问指针的B+Tree，这样做是为了提高区间查找的效率，只要找到第一个值那么就可以顺序的查找后面的值。</p><p>B+Tree的结构图如下：<br><img src="mysql-index-b+tree2.png" class="lazyload" data-srcset="mysql-index-b+tree2.png" srcset="data:image/png;base64,666" alt="B+Tree结构"></p></li></ul><h5 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h5><p>  分析了MySQL的索引结构的实现原理，然后我们来看看具体的存储引擎怎么实现索引结构的，MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。</p><p>  聚簇索引的解释是:聚簇索引的顺序就是数据的物理存储顺序</p><p>  非聚簇索引的解释是:索引顺序与数据物理排列顺序无关</p><p>  （这样说起来并不好理解，让人摸不着头脑，清继续看下文，并在插图下方对上述两句话有解释）</p><p>  首先要介绍几个概念，在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。</p><h5 id="3-索引的优缺点"><a href="#3-索引的优缺点" class="headerlink" title="3. 索引的优缺点"></a>3. 索引的优缺点</h5><p>  优势：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；</p><p>  劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</p><h3 id="二、索引的使用场景"><a href="#二、索引的使用场景" class="headerlink" title="二、索引的使用场景"></a>二、索引的使用场景</h3><p>  数据库中表的数据量较大的情况下，对于查询响应时间不能满足业务需求，可以合理的使用索引提升查询效率。</p><h3 id="三、索引的分类和创建和修改删除等命令"><a href="#三、索引的分类和创建和修改删除等命令" class="headerlink" title="三、索引的分类和创建和修改删除等命令"></a>三、索引的分类和创建和修改删除等命令</h3><h5 id="1-基本索引类型"><a href="#1-基本索引类型" class="headerlink" title="1. 基本索引类型"></a>1. 基本索引类型</h5><p>  ① 普通索引（单列索引）</p><ul><li><p>创建普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建组合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(column1, column2, column3);</span><br></pre></td></tr></table></figure><p>② 唯一索引<br>用来建立索引的列的值必须是唯一的，允许空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name(<span class="string">&#x27;col&#x27;</span>)；</span><br></pre></td></tr></table></figure><p>④ 主键索引<br>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p>⑤ 全文索引<br>是目前搜索引擎使用的一种关键技术。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-创建的语句"><a href="#2-创建的语句" class="headerlink" title="2. 创建的语句"></a>2. 创建的语句</h5>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name[col_name data type]</span><br><span class="line">[<span class="keyword">unique</span><span class="operator">|</span>fulltext][index<span class="operator">|</span>key][index_name](col_name[length])[<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure><ul><li><p>unique|fulltext为可选参数，分别表示唯一索引、全文索引</p></li><li><p>index和key为同义词，两者作用相同，用来指定创建索引</p></li><li><p>col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</p></li><li><p>index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</p></li><li><p>length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</p></li><li><p>asc或desc指定升序或降序的索引值存储</p></li></ul><h5 id="3-索引的创建、查询和删除"><a href="#3-索引的创建、查询和删除" class="headerlink" title="3. 索引的创建、查询和删除"></a>3. 索引的创建、查询和删除</h5><ol><li><p>索引的创建  </p><ul><li>普通索引（单列索引）<br>单列索引是最基本的索引，它没有任何限制。</li></ul><ul><li>直接创建索引  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name);</span><br></pre></td></tr></table></figure></li><li>修改表结构的方式添加索引  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(col_name);</span><br></pre></td></tr></table></figure></li><li>创建表的时候同时创建索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `news` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT ,</span><br><span class="line">    `title` <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `content` <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">    `<span class="type">time</span>` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">    INDEX index_name (title(<span class="number">255</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>删除索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `表名` <span class="keyword">drop</span> index 索引名;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>复合索引（组合索引）</p></li><li><p>唯一索引</p></li><li><p>主键索引</p></li><li><p>全文索引</p></li></ol><h3 id="四、简单实例演示"><a href="#四、简单实例演示" class="headerlink" title="四、简单实例演示"></a>四、简单实例演示</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、索引概述&quot;&gt;&lt;a href=&quot;#一、索引概述&quot; class=&quot;headerlink&quot; title=&quot;一、索引概述&quot;&gt;&lt;/a&gt;一、索引概述&lt;/h3&gt;&lt;h5 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/MySQL/"/>
    
    
    <category term="索引" scheme="https://hutaozhang.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Index" scheme="https://hutaozhang.github.io/tags/Index/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Database 索引</title>
    <link href="https://hutaozhang.github.io/posts/28156.html"/>
    <id>https://hutaozhang.github.io/posts/28156.html</id>
    <published>2021-03-06T13:40:50.006Z</published>
    <updated>2021-03-07T10:07:56.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-数据库索引"><a href="#一、-数据库索引" class="headerlink" title="一、 数据库索引"></a>一、 数据库索引</h2><h4 id="数据库索引定义"><a href="#数据库索引定义" class="headerlink" title="数据库索引定义"></a>数据库索引定义</h4><p>  索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p><p>  <strong>简而言之：</strong> 索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p><h4 id="数据库索引类别"><a href="#数据库索引类别" class="headerlink" title="数据库索引类别"></a>数据库索引类别</h4><p>  数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为聚簇索引和非聚簇索引两种：<br>  <em>聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。</em></p><p>  根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。有关数据库所支持的索引功能的详细信息，请参见数据库文档。<br>  提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><p>  <strong>唯一索引</strong><br>  唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p><p>  <strong>主键索引</strong><br>  数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p><p>  *<strong>聚集索引</strong><br>  在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</p><p>  <strong>索引列</strong><br>  可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</p><p>  检查查询的WHERE和JOIN子句。在任一子句中包括的每一列都是索引可以选择的对象。对新索引进行试验以检查它对运行查询性能的影响。考虑已在表上创建的索引数量。最好避免在单个表上有很多索引。检查已在表上创建的索引的定义。最好避免包含共享列的重叠索引。</p><p>  检查某列中唯一数据值的数量，并将该数量与表中的行数进行比较。比较的结果就是该列的可选择性，这有助于确定该列是否适合建立索引，如果适合，确定索引的类型。</p><h4 id="数据库索引特性"><a href="#数据库索引特性" class="headerlink" title="数据库索引特性"></a>数据库索引特性</h4><p>  <strong>基本特点</strong><br>  建立索引的目的是加快对表中记录的查找或排序。为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。数据库索引就是为了提高表的搜索效率而对某些字段中的值建立的目录 。</p><p>  创建索引可以大大提高系统的性能。第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>  因为，增加索引也有许多不利的方面。第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>  <strong>优点</strong><br>  通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点 ：</p><ul><li>在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。</li><li>能提高数据的搜索及检索速度，符合数据库建立的初衷。</li><li>能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。</li><li>在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。</li><li>建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。</li></ul><p>  <strong>缺点</strong><br>  虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点：</p><ul><li>在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。</li><li>在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加</li><li>在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。</li></ul><p>  <strong>注意事项</strong><br>  索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：</p><ul><li><p>在经常需要搜索的列上，可以加快搜索的速度；</p></li><li><p>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p></li><li><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p></li><li><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p></li><li><p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点：</p></li><li><p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p></li><li><p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p></li><li><p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。</p></li><li><p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-数据库索引&quot;&gt;&lt;a href=&quot;#一、-数据库索引&quot; class=&quot;headerlink&quot; title=&quot;一、 数据库索引&quot;&gt;&lt;/a&gt;一、 数据库索引&lt;/h2&gt;&lt;h4 id=&quot;数据库索引定义&quot;&gt;&lt;a href=&quot;#数据库索引定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="教程" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E6%95%99%E7%A8%8B/Database/"/>
    
    
    <category term="Database" scheme="https://hutaozhang.github.io/tags/Database/"/>
    
    <category term="索引" scheme="https://hutaozhang.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Index" scheme="https://hutaozhang.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>面试 MySQL MVCC</title>
    <link href="https://hutaozhang.github.io/posts/2460.html"/>
    <id>https://hutaozhang.github.io/posts/2460.html</id>
    <published>2021-03-06T13:40:23.288Z</published>
    <updated>2021-03-07T10:03:22.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前提概要"><a href="#一、前提概要" class="headerlink" title="一、前提概要"></a>一、前提概要</h4><blockquote><p>MVCC<br>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote><h5 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h5><p>  MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p><h5 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h5><p>  在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p><ul><li><p>当前读<br>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p></li><li><p>快照读<br>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p></li></ul><p>  <strong>当前读，快照读和MVCC的关系</strong></p><ul><li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li><li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li><li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</li></ul><h5 id="MVCC能解决什么问题，好处是？"><a href="#MVCC能解决什么问题，好处是？" class="headerlink" title="MVCC能解决什么问题，好处是？"></a>MVCC能解决什么问题，好处是？</h5><p>  <strong>数据库并发场景有三种，分别为：</strong></p><ul><li>读-读：不存在任何问题，也不需要并发控制</li><li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><p>  <strong>MVCC带来的好处是？</strong><br>  多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li><li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li></ul><p>  <strong>小结一下</strong><br>  总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p><ul><li>MVCC + 悲观锁<br>MVCC解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁<br>MVCC解决读写冲突，乐观锁解决写写冲突<br>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</li></ul><h4 id="二、MVCC的实现原理"><a href="#二、MVCC的实现原理" class="headerlink" title="二、MVCC的实现原理"></a>二、MVCC的实现原理</h4><p>  MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念</p><p>  <strong>隐式字段</strong><br>  每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><ul><li><p>DB_TRX_ID<br>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p></li><li><p>DB_ROLL_PTR<br>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p></li><li><p>DB_ROW_ID<br>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引<br>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-yincang.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-yincang.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></p><p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本</p></li></ul><p>  <strong>undo日志</strong></p><p>  undo log主要分为两种：</p><ul><li><p>insert undo log<br>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p></li><li><p>update undo log<br>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><blockquote><p>purge</p><ul><li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></blockquote><p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p><p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo1.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo1.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>二、 现在来了一个事务1对该记录的name做出了修改，改为Tom</p></li><li><p>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</p></li><li><p>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</p></li><li><p>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</p></li><li><p>事务提交后，释放锁<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo2.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo2.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>三、 又来了个事务2修改person表的同一个记录，将age修改为30岁</p></li><li><p>在事务2修改该行数据时，数据库也先为该行加锁</p></li><li><p>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</p></li><li><p>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</p></li><li><p>事务提交，释放锁<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo3.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo3.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p></li></ul><p>  <strong>Read View(读视图)</strong><br>  什么是Read View?<br>  什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>  所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>  Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p><p>  那么这个判断条件是什么呢？<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo4.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo4.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>  如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较</p><p>  在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p><blockquote><p>trx_list（名字我随便取的）<br>一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID<br>up_limit_id<br>记录trx_list列表中事务ID最小的ID<br>low_limit_id<br>ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p></blockquote><ul><li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li><li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li><li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li></ul><p>  <strong>整体流程</strong><br>  我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p><p>  整体的流程是怎么样的呢？我们可以模拟一下</p><ul><li>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo5.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo5.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo6.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo6.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo7.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo7.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo8.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-undo8.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"></li><li>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li></ul><h3 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h3><h5 id="RR是如何在RC级的基础上解决不可重复读的？"><a href="#RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="RR是如何在RC级的基础上解决不可重复读的？"></a>RR是如何在RC级的基础上解决不可重复读的？</h5><p>  当前读和快照读在RR级别下的区别：<br>  表1:<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>  表2:<br>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc1.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-mvcc-rc1.webp" srcset="data:image/png;base64,666" alt="MVCC隐藏"><br>  而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p><ul><li><p>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。<br>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</p><p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p></li></ul><h5 id="RC-RR级别下的InnoDB快照读有什么不同？"><a href="#RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="RC,RR级别下的InnoDB快照读有什么不同？"></a>RC,RR级别下的InnoDB快照读有什么不同？</h5><p>  正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><ul><li><p>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p></li><li><p>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</p></li><li><p>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</p><p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前提概要&quot;&gt;&lt;a href=&quot;#一、前提概要&quot; class=&quot;headerlink&quot; title=&quot;一、前提概要&quot;&gt;&lt;/a&gt;一、前提概要&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;MVCC&lt;br&gt;MVCC，全称Multi-Version Concurrency </summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
    <category term="面试" scheme="https://hutaozhang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MVCC" scheme="https://hutaozhang.github.io/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>面试 MySQL 索引</title>
    <link href="https://hutaozhang.github.io/posts/43567.html"/>
    <id>https://hutaozhang.github.io/posts/43567.html</id>
    <published>2021-03-06T13:33:13.730Z</published>
    <updated>2021-03-08T15:10:00.920Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>  索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>  索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>  更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><h5 id="索引有哪些优点？"><a href="#索引有哪些优点？" class="headerlink" title="索引有哪些优点？"></a>索引有哪些优点？</h5><ul><li><p>索引的优点</p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul></li><li><p>索引的缺点</p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul></li></ul><h5 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h5><h5 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h5><ul><li><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p></li><li><p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</p></li><li><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</p></li></ul></li><li><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li><p>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</p></li><li><p>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</p></li></ul></li><li><p>全文索引： 是目前搜索引擎使用的一种关键技术。</p><ul><li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li></ul></li></ul><h5 id="索引的数据结构（BTree，B-Tree）"><a href="#索引的数据结构（BTree，B-Tree）" class="headerlink" title="索引的数据结构（BTree，B+Tree）"></a>索引的数据结构（BTree，B+Tree）</h5><p>  索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><ol><li><p>BTree<br>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p></li><li><p>B+Tree<br>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p></li><li><p>哈希索引<br>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p></li></ol><h5 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h5><p>  索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>  索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li><p>把创建了索引的列的内容进行排序</p></li><li><p>对排序结果生成倒排表</p></li><li><p>在倒排表内容上拼上数据地址链</p></li><li><p>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p></li></ol><h5 id="索引的算法有哪些？"><a href="#索引的算法有哪些？" class="headerlink" title="索引的算法有哪些？"></a>索引的算法有哪些？</h5><p>  索引算法有 BTree算法和Hash算法<br>  <strong>BTree算法</strong><br>  BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只要它的查询条件是一个不以通配符开头的常量</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;jack%&#x27;</span>; </span><br><span class="line"><span class="comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%jack&#x27;</span>; </span><br></pre></td></tr></table></figure></p><p>  <strong>Hash算法</strong><br>  Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><h5 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h5><ol><li><p>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</p></li><li><p>基数较小的类，索引效果较差，没有必要在此列建立索引</p></li><li><p>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p></li><li><p>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p></li></ol><h5 id="创建索引的原则？（重点）"><a href="#创建索引的原则？（重点）" class="headerlink" title="创建索引的原则？（重点）"></a>创建索引的原则？（重点）</h5><p>  索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>  1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>  2）较频繁作为查询条件的字段才去创建索引</p><p>  3）更新频繁字段不适合创建索引</p><p>  4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>  5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>  6）定义有外键的数据列一定要建立索引。</p><p>  7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>  8）对于定义为text、image和bit的数据类型的列不要建立索引。</p><h5 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a>创建索引的三种方式，删除索引</h5><p>  <strong>创建索引</strong><br>  第一种方式：在执行CREATE TABLE时创建索引<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">id <span class="type">INT</span> auto_increment <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">last_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">id_card <span class="type">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">information text,</span><br><span class="line">KEY name (first_name, last_name),</span><br><span class="line">FULLTEXT KEY (information),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>  第二种方式：使用ALTER TABLE命令去增加索引<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column_list);</span><br></pre></td></tr></table></figure><br>  ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。<br>  其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>  索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>  第三种方式：使用CREATE INDEX命令创建<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure><br>  CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p>  <strong>删除索引</strong><br>  根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code><br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY information;</span><br></pre></td></tr></table></figure></p><p>  删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> <span class="keyword">key</span>;</span><br><span class="line">[<span class="keyword">SQL</span>]<span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> <span class="keyword">KEY</span></span><br><span class="line">[Err]<span class="number">1075</span> <span class="operator">-</span> Incorrect <span class="keyword">table</span> definition, there can be <span class="keyword">only</span> <span class="keyword">one</span> auto <span class="keyword">column</span> <span class="keyword">and</span> it must be defined <span class="keyword">as</span> a key</span><br></pre></td></tr></table></figure><br>  需要取消自增长再行删除：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line">MODIFY id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure><br>  但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h5 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h5><ul><li><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p></li><li><p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p></li><li><p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p></li></ul><h5 id="使用索引时需要注意什么？"><a href="#使用索引时需要注意什么？" class="headerlink" title="使用索引时需要注意什么？"></a>使用索引时需要注意什么？</h5><p>  通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><ul><li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ul><h5 id="百万级别或以上的数据如何删除？"><a href="#百万级别或以上的数据如何删除？" class="headerlink" title="百万级别或以上的数据如何删除？"></a>百万级别或以上的数据如何删除？</h5><p>  关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><p>  语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>  前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>  实操的难度：在于前缀截取的长度。</p><p>  我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p><h5 id="什么是最左原则？什么是最左匹配原则？"><a href="#什么是最左原则？什么是最左匹配原则？" class="headerlink" title="什么是最左原则？什么是最左匹配原则？"></a>什么是最左原则？什么是最左匹配原则？</h5><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 </li><li></li><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li></li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h5 id="BTree和B-Tree的区别？"><a href="#BTree和B-Tree的区别？" class="headerlink" title="BTree和B+Tree的区别？"></a>BTree和B+Tree的区别？</h5><p>  在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p><p>  B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p>  <img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-btree-b+tree-diff.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-btree-b+tree-diff.png" srcset="data:image/png;base64,666" alt="B数和B+树的区别"></p><h5 id="使用BTree的好处？"><a href="#使用BTree的好处？" class="headerlink" title="使用BTree的好处？"></a>使用BTree的好处？</h5><p>  B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h5 id="使用B-Tree的好处？"><a href="#使用B-Tree的好处？" class="headerlink" title="使用B+Tree的好处？"></a>使用B+Tree的好处？</h5><p>  由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h5 id="Hash索引和B-Tree有什么区别或者说优劣？"><a href="#Hash索引和B-Tree有什么区别或者说优劣？" class="headerlink" title="Hash索引和B+Tree有什么区别或者说优劣？"></a>Hash索引和B+Tree有什么区别或者说优劣？</h5><p>  首先要知道Hash索引和B+树索引的底层实现原理：</p><p>  hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>  那么可以看出他们有以下的不同：</p><ul><li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p></li><li><p>hash索引不支持使用索引进行排序，原理同上。</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p></li><li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p></li><li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p></li></ul><h5 id="数据库为什么使用B-Tree而不是BTree？"><a href="#数据库为什么使用B-Tree而不是BTree？" class="headerlink" title="数据库为什么使用B+Tree而不是BTree？"></a>数据库为什么使用B+Tree而不是BTree？</h5><ul><li><p>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p></li><li><p>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</p></li><li><p>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</p></li><li><p>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</p></li><li><p>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p></li></ul><h5 id="B-Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据"><a href="#B-Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据" class="headerlink" title="B+Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据"></a>B+Tree在满足聚簇索引和覆盖索引的时候不需要回表查询数据</h5><p>  在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>  当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><h5 id="什么是聚簇索引？合适使用聚簇索引？"><a href="#什么是聚簇索引？合适使用聚簇索引？" class="headerlink" title="什么是聚簇索引？合适使用聚簇索引？"></a>什么是聚簇索引？合适使用聚簇索引？</h5><ul><li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p></li><li><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>何时使用聚簇索引与非聚簇索引<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-jucu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-jucu.png" srcset="data:image/png;base64,666" alt="何时使用聚簇索引与非聚簇索引"></p></li></ul><h5 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h5><p>  不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>  举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h5 id="联合索引时什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引时什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引时什么？为什么需要注意联合索引中的顺序？"></a>联合索引时什么？为什么需要注意联合索引中的顺序？</h5><p>  MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>  具体原因为:</p><p>  MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>  当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h5 id="索引是什么？有什么作用？"><a href="#索引是什么？有什么作用？" class="headerlink" title="索引是什么？有什么作用？"></a>索引是什么？有什么作用？</h5><p>  MySQL索引是什么？MySQL索引有什么作用？<br>  索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的IO成本。MySQL官方文档说500~800w条记录左右性能开始逐渐下降，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。</p><h5 id="导致SQL执行慢的原因"><a href="#导致SQL执行慢的原因" class="headerlink" title="导致SQL执行慢的原因"></a>导致SQL执行慢的原因</h5><ul><li>硬件问题。（如网速慢，内存不足，I / O 吞吐量小，磁盘空间满了等）</li><li>没有索引或索引失效。（一般在互联网公司，DBA会在半夜把表锁了，重新建立一遍索引，因为当你删除某个数据的时候，索引的树结构就不完整了。所以互联网公司的数据做的是假删除.一是为了做数据分析,二是为了不破坏索引）</li><li>数据过多。（官方文档说500W-800W条数据之后性能逐渐开始下降）</li><li>服务器调优及各个参数设置。（调整my.cnf）</li></ul><h5 id="如何解决这些问题呢？"><a href="#如何解决这些问题呢？" class="headerlink" title="如何解决这些问题呢？"></a>如何解决这些问题呢？</h5><ul><li>先观察，开启慢查询日志，设置相应的阈值（比如超过3秒就是慢SQL），在生产环境跑上个一天过后，看看哪些SQL比较慢。</li><li>Explain和慢SQL分析。比如SQL语句写的烂，索引没有或失效，关联查询太多（有时候是设计缺陷或者不得以的需求）等等。</li><li>Show Profile是比Explain更近一步的执行细节，可以查询到执行每一个SQL都干了什么事，这些事分别花了多少秒。</li><li>找DBA或者运维对MySQL进行服务器的参数调优。</li></ul><h5 id="什么是索引？-1"><a href="#什么是索引？-1" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。 Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引如图所示：<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-b+tree.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-b+tree.png" srcset="data:image/png;base64,666" alt="MySQL B+Tree"></p><p>最外层浅蓝色磁盘块1里有数据17、35（深蓝色）和指针P1、P2、P3（黄色）。P1指针表示小于17的磁盘块，P2是在17-35之间，P3指向大于35的磁盘块。真实数据存在于子叶节点也就是最底下的一层3、5、9、10、13…非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35。 查找过程：例如搜索28数据项，首先加载磁盘块1到内存中，发生一次I/O，用二分查找确定在P2指针。接着发现28在26和30之间，通过P2指针的地址加载磁盘块3到内存，发生第二次I/O。用同样的方式找到磁盘块8，发生第三次I/O。真实的情况是，上面3层的B+Tree可以表示上百万的数据，上百万的数据只发生了三次I/O而不是上百万次I/O，时间提升是巨大的。</p><p><strong>那我们在什么情况下该创建索引呢？</strong><br>索引虽然能非常高效的提高查询速度，同时却会降低更新表的速度。实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。<br><img src="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-create.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/hutaozhang/CDN/blog/images/mysql-index-create.png" srcset="data:image/png;base64,666" alt="MySQL B+Tree"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么是索引？&quot; class=&quot;headerlink&quot; title=&quot;什么是索引？&quot;&gt;&lt;/a&gt;什么是索引？&lt;/h5&gt;&lt;p&gt;  索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/MySQL/"/>
    
    
    <category term="索引" scheme="https://hutaozhang.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Index" scheme="https://hutaozhang.github.io/tags/Index/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
    <category term="面试" scheme="https://hutaozhang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试 MySQL 事务</title>
    <link href="https://hutaozhang.github.io/posts/29528.html"/>
    <id>https://hutaozhang.github.io/posts/29528.html</id>
    <published>2021-03-06T13:14:51.911Z</published>
    <updated>2021-03-08T15:23:43.504Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h5><p>  事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>  事务最经典也经常被拿出来说例子就是转账了。</p><p>  假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h5 id="事物的四大特性ACID介绍一下？"><a href="#事物的四大特性ACID介绍一下？" class="headerlink" title="事物的四大特性ACID介绍一下？"></a>事物的四大特性ACID介绍一下？</h5><ul><li><p>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p></li><li><p>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h5 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h5><ul><li><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p></li><li><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p></li><li><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p></li></ul><h5 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h5><p>  为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center"></td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center"></td><td align="center"></td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>  SQL 标准定义了四个隔离级别：</p><ul><li><p>READ-UNCOMMITTED(<strong>读取未提交</strong>)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p>READ-COMMITTED(<strong>读取已提交</strong>)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p>REPEATABLE-READ(<strong>可重复读</strong>)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p>SERIALIZABLE(<strong>可串行化</strong>)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h5&gt;&lt;p&gt;  事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状</summary>
      
    
    
    
    <category term="面试" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Database" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/"/>
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/categories/%E9%9D%A2%E8%AF%95/Database/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hutaozhang.github.io/tags/MySQL/"/>
    
    <category term="面试" scheme="https://hutaozhang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
